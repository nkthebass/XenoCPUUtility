<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<title>Xeno CPU utility 1.9.0</title>
<style>
    /* General Styles */
    body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        /* Smooth vertical 3-color gradient background, always fills viewport */
        background: linear-gradient(180deg, var(--bg-grad1, #e0e7ff) 0%, var(--bg-grad2, #f0f0f0) 50%, var(--bg-grad3, #ffe0e7) 100%);
        background-repeat: no-repeat;
        background-attachment: fixed;
        background-size: 100vw 100vh;
        color: #333;
        padding: 15px;
        margin: 0;
        min-height: 100vh;
        overflow-y: auto; 
        position: relative; 
    }
    
    .main-container {
        width: 600px; 
        position: absolute;
        left: 50%; 
        margin-left: -300px; 
        background-color: transparent;
        border-radius: 5px; 
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        padding: 20px;
        box-sizing: border-box;
        text-align: left;
    }
    
    .panel { padding: 20px 0; text-align: center; margin-bottom: 20px; border-bottom: 1px solid #e0e0e0; }
    .panel:last-child { border-bottom: none; margin-bottom: 0; }

    h1 { font-size: 1.4em; color: #0056b3; margin-bottom: 5px; padding-bottom: 8px; font-weight: 700; text-transform: uppercase; }
    .status-text { margin: 15px 0 25px; font-size: 1.1em; font-weight: bold; min-height: 20px; color: #0056b3; }
    .button-group { display: flex; justify-content: center; gap: 10px; }
    .button-group button { background-color: #007bff; color: white; border: none; padding: 10px 18px; border-radius: 4px; cursor: pointer; transition: background-color 0.2s, transform 0.1s; font-size: 0.9em; font-weight: 600; min-width: 100px; box-shadow: 0 2px 5px rgba(0,0,0,0.1);} 
    .button-group button:hover { background-color: #0056b3; }
    .button-group button:active { transform: scale(0.98); }
    #stopBtn { background-color: #dc3545; }
    #stopBtn:hover { background-color: #c82333; }
    button:disabled { background-color: #a0a0a0 !important; cursor: not-allowed; box-shadow: none; }

    .run-count-control { margin-bottom: 20px; display: flex; align-items: center; justify-content: center; }
    #runCountInput { padding: 5px 10px; border-radius: 3px; border: 1px solid #ccc; margin-left: 10px; font-size: 1em; width: 50px; text-align: center; }
    .cores-control { margin-bottom: 20px; display: flex; align-items: center; justify-content: center; }
    #coresInput { padding: 5px 10px; border-radius: 3px; border: 1px solid #ccc; margin-left: 10px; font-size: 1em; width: 60px; text-align: center; }
    .score-display { font-size: 3em; font-weight: 800; color: #0056b3; margin: 15px 0; display: block; }

    .static-info-container { margin-top: 25px; padding: 15px; background-color: #f9f9f9; border-radius: 5px; text-align: left; }
    .static-info-container h2 { font-size: 1.1em; color: #0056b3; margin-bottom: 10px; border-bottom: 1px dashed #cceeff; padding-bottom: 5px; }
    .static-specs { display: flex; justify-content: space-around; margin-top: 10px; font-size: 0.9em; }
    .static-specs div { background-color: #e6ffe6; padding: 6px 10px; border-radius: 3px; flex: 1; margin: 0 5px; text-align: center; }
    .static-specs strong { display: block; font-size: 1em; color: #28a745; }

    .progress-bar-wrapper { width: 80%; margin: 20px auto 0; background-color: #e9ecef; border-radius: 10px; overflow: hidden; border: 1px solid #ced4da; box-shadow: inset 0 1px 2px rgba(0,0,0,0.1); position: relative; }
    .progress-bar { height: 20px; background-color: #17a2b8; width: 0%; transition: width 0.05s linear; }
    #progressText { position: absolute; width: 100%; text-align: center; line-height: 20px; color: #000; font-weight: 700; top: 0; font-size: 0.9em; z-index: 10; }
    /* Sidebar Toggle Buttons */
    .sidebar-toggle-row {
        display: flex;
        flex-direction: column;
        gap: 0;
        position: fixed;
        right: 0;
        top: 40%;
        z-index: 9999;
    }

    .sidebar-toggle-row button {
        background: #007bff;
        color: #fff;
        padding: 8px 10px;
        border: none;
        cursor: pointer;
        font-weight: 700;
        box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        transition: background 0.2s;
    }

    .sidebar-toggle-row button:first-child { border-top-left-radius: 6px; }
    .sidebar-toggle-row button:last-child { border-bottom-left-radius: 6px; }
    .sidebar-toggle-row button.active { background: #0056b3; }
    .sidebar-toggle-row button:hover { background: #0056b3; }

    .custom-sidebar {
        position: fixed;
        right: 0;
        top: 0;
        height: 100%;
        width: 320px;
        max-width: 90%;
        background: #ffffff;
        box-shadow: -6px 0 18px rgba(0,0,0,0.15);
        transform: translateX(100%);
        transition: transform 0.25s ease-in-out;
        z-index: 9998;
        padding: 18px;
        box-sizing: border-box;
        overflow-y: auto;
    }

    .custom-sidebar.open { transform: translateX(0%); }

    .custom-sidebar h3 { margin-top: 0; color: #0056b3; }
    .custom-sidebar label { display: block; margin-top: 10px; font-weight: 600; font-size: 0.95em; }
    .custom-sidebar input[type="color"] { margin-top: 6px; width: 60px; height: 34px; border: none; padding: 0; background: none; cursor: pointer; }
    .custom-sidebar .preset-row { display:flex; gap:8px; margin-top:10px; }
    .custom-sidebar button { margin-top: 12px; padding: 8px 10px; border-radius:4px; border:none; cursor:pointer; }
    .custom-sidebar .save-btn { background:#28a745; color:#fff; }
    .custom-sidebar .reset-btn { background:#dc3545; color:#fff; margin-left:8px; }

    /* Benchmarks Sidebar */
    .benchmarks-sidebar {
        position: fixed;
        right: 0;
        top: 0;
        height: 100%;
        width: 320px;
        max-width: 90%;
        background: #ffffff;
        box-shadow: -6px 0 18px rgba(0,0,0,0.15);
        transform: translateX(100%);
        transition: transform 0.25s ease-in-out;
        z-index: 9998;
        padding: 18px;
        box-sizing: border-box;
        overflow-y: auto;
    }

    .benchmarks-sidebar.open { transform: translateX(0%); }
    .benchmarks-sidebar h3 { margin-top: 0; color: #0056b3; }
    .benchmarks-sidebar canvas { max-width: 100%; margin-top: 12px; display: block; }

    .alerts-sidebar {
        position: fixed;
        right: 0;
        top: 0;
        height: 100%;
        width: 320px;
        max-width: 90%;
        background: #ffffff;
        box-shadow: -6px 0 18px rgba(0,0,0,0.15);
        transform: translateX(100%);
        transition: transform 0.25s ease-in-out;
        z-index: 9998;
        padding: 18px;
        box-sizing: border-box;
        overflow-y: auto;
    }

    .alerts-sidebar.open { transform: translateX(0%); }
    .alerts-sidebar h3 { margin-top: 0; color: #b22222; }
    .alerts-summary { margin-top: 12px; font-size: 0.9em; color: #666; line-height: 1.4; }
    .alerts-sidebar .alerts-clear-btn {
        margin-top: 14px;
        padding: 8px 10px;
        border-radius: 4px;
        border: none;
        cursor: pointer;
        background: #6c757d;
        color: #fff;
        font-weight: 600;
    }
    .alerts-sidebar .alerts-clear-btn:hover { background: #5a636a; }

    /* WHEA Sidebar */
    .whea-sidebar {
        position: fixed;
        right: 0;
        top: 0;
        height: 100%;
        width: 320px;
        max-width: 90%;
        background: #ffffff;
        box-shadow: -6px 0 18px rgba(0,0,0,0.15);
        transform: translateX(100%);
        transition: transform 0.25s ease-in-out;
        z-index: 9998;
        padding: 18px;
        box-sizing: border-box;
        overflow-y: auto;
    }

    .whea-sidebar.open { transform: translateX(0%); }
    .whea-sidebar h3 { margin-top: 0; color: #d9534f; }
    .whea-sidebar h4 { color: #d9534f; margin-top: 14px; margin-bottom: 8px; font-size: 0.95em; }
    .whea-sidebar p { font-size: 0.9em; color: #666; line-height: 1.4; }
    .whea-sidebar .whea-error-list { margin-top: 10px; }
    .whea-sidebar .whea-error-item { background-color: #fff3cd; padding: 8px; margin-bottom: 8px; border-radius: 3px; border-left: 3px solid #d9534f; font-size: 0.85em; color: #333; }
    .whea-sidebar .whea-clear-btn {
        margin-top: 14px;
        padding: 8px 10px;
        border-radius: 4px;
        border: none;
        cursor: pointer;
        background: #d9534f;
        color: #fff;
        font-weight: 600;
    }
    .whea-sidebar .whea-clear-btn:hover { background: #c9302c; }
    .whea-summary { margin-top: 12px; font-size: 0.9em; color: #666; line-height: 1.4; padding: 10px; background-color: #f5f5f5; border-radius: 3px; }

    /* About Sidebar */
    .about-sidebar {
        position: fixed;
        right: 0;
        top: 0;
        height: 100%;
        width: 320px;
        max-width: 90%;
        background: #ffffff;
        box-shadow: -6px 0 18px rgba(0,0,0,0.15);
        transform: translateX(100%);
        transition: transform 0.25s ease-in-out;
        z-index: 9998;
        padding: 18px;
        box-sizing: border-box;
        overflow-y: auto;
    }

    .about-sidebar.open { transform: translateX(0%); }
    .about-sidebar h3 { margin-top: 0; color: #0056b3; }
    .about-sidebar h4 { color: #0056b3; margin-top: 16px; margin-bottom: 8px; }
    .about-sidebar p { font-size: 0.9em; color: #666; line-height: 1.5; }
    .about-sidebar .info-section { margin-top: 14px; padding: 12px; background-color: #f9f9f9; border-radius: 4px; border-left: 3px solid #0056b3; }
    .about-sidebar .info-section p { margin: 6px 0; font-size: 0.9em; }

#cpuHistogramContainer {
        transition: opacity 0.3s;
    }

    #cpuHistogramContainer.faded {
        opacity: 0.35;
        pointer-events: none;
    }

    .histogram-toggle-row {
        display: flex;
        justify-content: flex-end;
        align-items: center;
        gap: 8px;
        margin-bottom: 2px;
    }

    .histogram-toggle-row button {
        background: #007bff;
        color: #fff;
        border: none;
        border-radius: 5px;
        padding: 2px 10px;
        font-size: 12px;
        cursor: pointer;
        opacity: 0.85;
        transition: background 0.2s, opacity 0.2s;
    }
    .histogram-toggle-row button.active {
        background: #0056b3;
        opacity: 1;
    }
    .histogram-toggle-row button:hover {
        background: #0056b3;
        opacity: 1;
    }
    .histogram-run-label {
        font-size: 12px;
        color: #888;
        margin-right: auto;
        margin-left: 2px;
        margin-top: 10px;
        padding: 8px;
        border-radius: 8px;
        background: rgba(255,255,255,0.03);
    }

#cpuHistogramContainer {
    overflow: hidden;
    position: relative;
    transition: height 0.2s;
}
.histogram-hidden {
    height: 0 !important;
    min-height: 0 !important;
    max-height: 0 !important;
    padding: 0 !important;
    margin: 0 !important;
    opacity: 0;
    pointer-events: none;
}
#benchmarkHistogram {
    width: 100% !important;
    height: 160px !important;
    max-height: 160px !important;
    min-height: 160px !important;
    display: block;
    margin: 0 auto;
}

.histogramHeader {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 13px;
    margin-bottom: 4px;
}

.histogramHeader button {
    background: rgba(255,255,255,0.08);
    border: none;
    color: #fff;
    padding: 2px 8px;
    border-radius: 6px;
    cursor: pointer;
}

.histogramHeader button:hover {
    background: rgba(255,255,255,0.15);
}

</style>

<script>
// Ensure all needed functions are global for HTML event handlers
window.Window_OnUnload = Window_OnUnload;
window.ToggleSidebar = ToggleSidebar;
window.StartMultiCoreBenchmark = StartMultiCoreBenchmark;
// --- Warm-up logic ---
function WarmUpCPU(callback, benchmarkType) {
    benchmarkType = benchmarkType || 'single';  // Default to single-core
    document.getElementById("benchBtn").disabled = true;
    document.getElementById("multiBenchBtn").disabled = true;
    document.getElementById("runCountInput").disabled = true;
    document.getElementById("benchResult").innerHTML = "--";
    document.getElementById("benchDetails").innerText = "Warming up CPU for 8 seconds (Heavy Load - All Cores)...";
    UpdateStatus("benchStatus", "Warming up (heavy load stress on all cores)...", "#ff9800");
    document.getElementById("progressBarFill").style.width = '0%';
    document.getElementById("progressText").innerText = '0%';
    
    var pauseDuration = 1500;  // 1.5 second pause after warmup
    
    // Run a single benchmark iteration as warmup instead of stress test
    if (benchmarkType === 'multi') {
        // Multi-core warmup: run one quick multi-core benchmark
        hostInvoke('runMultiCoreBenchmark', { durationSeconds: 0.8, numRuns: 1 }).then(function(result) {
            document.getElementById("progressBarFill").style.width = '100%';
            document.getElementById("progressText").innerText = '100%';
            setTimeout(callback, pauseDuration);
        }).catch(function(err) {
            console.error('Multi-core warmup error:', err);
            document.getElementById("progressBarFill").style.width = '100%';
            document.getElementById("progressText").innerText = '100%';
            setTimeout(callback, pauseDuration);
        });
    } else {
        // Single-core warmup: run one quick single-core benchmark
        ResetRunState();
        var warmupStartTime = Date.now();
        var warmupDuration = BENCHMARK_CHUNK_DURATION * 1000;  // Convert to milliseconds
        
        function warmupBenchmark() {
            f_val = Math.sqrt(f_val * 0.999999 + 0.000001);
            f_val = Math.sin(f_val) + Math.cos(f_val);
            i_val = ((i_val ^ 61) ^ (i_val >> 13));
            total_iterations++;
            
            var elapsed = Date.now() - warmupStartTime;
            var progress = Math.min(100, (elapsed / warmupDuration) * 100);
            document.getElementById("progressBarFill").style.width = progress.toFixed(0) + '%';
            document.getElementById("progressText").innerText = progress.toFixed(0) + '%';
            
            if (elapsed < warmupDuration) {
                setTimeout(warmupBenchmark, 0);
            } else {
                document.getElementById("progressBarFill").style.width = '100%';
                document.getElementById("progressText").innerText = '100%';
                setTimeout(callback, pauseDuration);
            }
        }
        warmupBenchmark();
    }
}
// Global error handler for debugging
window.onerror = function(msg, url, line, col, error) {
    console.error('Global error:', msg, 'at', line + ':' + col);
    return false;
};

console.log('Script started, checking WebView2 bridge...');
if (typeof window.chrome !== 'undefined' && window.chrome.webview) {
    console.log('WebView2 bridge available');
} else {
    console.error('WebView2 bridge NOT available');
}

// Bridge helpers replacing ActiveX/HTA APIs with host calls (WebView2)
var CORE_LOCK_FILE = "core_lock.tmp";
var TEMP_PS_FILE = "stress_loop.ps1";
var htaDir = "";

// Message-based bridge using unique ids
function hostInvoke(cmd, args) {
    console.log('hostInvoke called:', cmd, JSON.stringify(args));
    return new Promise(function (resolve, reject) {
        if (!window.chrome || !window.chrome.webview) {
            console.error('WebView2 not available!');
            reject('WebView2 not available');
            return;
        }
        var id = Math.random().toString(36).slice(2);
        console.log('Generated request id:', id);
        function listener(e) {
            try {
                var m = e.data;
                console.log('Received message:', JSON.stringify(m));
                if (!m) return;
                if (m.replyTo === cmd && m.id === id) {
                    console.log('Message matched! Resolving with:', m.result);
                    window.chrome.webview.removeEventListener('message', listener);
                    resolve(m.result);
                }
            } catch (err) { 
                console.error('Listener error:', err);
            }
        }
        window.chrome.webview.addEventListener('message', listener);
        console.log('Sending message:', JSON.stringify({ cmd: cmd, args: args || {}, id: id }));
        window.chrome.webview.postMessage({ cmd: cmd, args: args || {}, id: id });
    });
}

// Also accept host's init message
window.chrome && window.chrome.webview && window.chrome.webview.addEventListener('message', function (e) {
    try {
        var m = e.data;
        if (!m) return;
        if (m.cmd === 'init' && m.appDir) {
            htaDir = m.appDir;
        }
        if (m.broadcast) {
            handleHostBroadcastMessage(m);
        }
    } catch (err) { }
});

function UpdateStatus(id, msg, color) {
    document.getElementById(id).innerText = msg;
    document.getElementById(id).style.color = color;
}

function formatMegabytes(mb) {
    if (isNaN(mb) || mb <= 0) return "Disabled";
    if (mb >= 1024) {
        var gb = mb / 1024;
        if (gb >= 1024) {
            return (gb / 1024).toFixed(1) + " TB";
        }
        var gbRounded = Math.round(gb * 10) / 10;
        return gbRounded.toString() + " GB";
    }
    return mb + " MB";
}

function describeCpuTarget(numThreads) {
    if (!numThreads || numThreads <= 0) return "CPU stress disabled.";
    return "Current CPU stress target: " + numThreads + " process(es).";
}

function describeRamTarget(mb) {
    if (!mb || mb <= 0) return "RAM stress disabled.";
    return "RAM stress target: " + formatMegabytes(mb) + ".";
}

function formatNumber(value) {
    if (typeof value !== 'number' || !isFinite(value)) return '';
    try {
        return value.toLocaleString();
    } catch (e) {
        return value.toString();
    }
}

function formatByte(value) {
    if (typeof value !== 'number' || value < 0) return '--';
    var hex = value.toString(16).toUpperCase();
    if (hex.length < 2) hex = '0' + hex;
    return '0x' + hex;
}

function formatDuration(ms) {
    if (typeof ms !== 'number' || !isFinite(ms) || ms < 0) return '--';
    if (ms < 1000) return ms.toFixed(0) + ' ms';
    return (ms / 1000).toFixed(2) + ' s';
}

function formatThroughput(throughputGbps) {
    if (typeof throughputGbps !== 'number' || !isFinite(throughputGbps) || throughputGbps < 0) return '--';
    if (throughputGbps >= 100) return throughputGbps.toFixed(0) + ' GB/s';
    if (throughputGbps >= 10) return throughputGbps.toFixed(1) + ' GB/s';
    return throughputGbps.toFixed(2) + ' GB/s';
}

function formatRamTooltip(percent) {
    if (typeof percent !== 'number' || !isFinite(percent)) return 'RAM: --';
    try {
        var usageText = percent.toFixed(1) + '%';
        if (typeof window.lastRamMetrics === 'object' && window.lastRamMetrics !== null && typeof window.lastRamMetrics.totalGB === 'number') {
            var totalGB = window.lastRamMetrics.totalGB;
            var inUseGB = window.lastRamMetrics.usedGB;
            if (typeof inUseGB !== 'number' || !isFinite(inUseGB)) {
                inUseGB = (percent / 100) * totalGB;
            }
            usageText += ' (' + inUseGB.toFixed(2) + ' GB of ' + totalGB.toFixed(2) + ' GB)';
        }
        return 'RAM: ' + usageText;
    } catch (e) {
        return 'RAM: ' + percent.toFixed(1) + '%';
    }
}

var alertsChart = null;
var ramMirrorChart = null;
var alertsHistoryLimit = 14;
var ramHistoryLabels = [];
var ramMismatchSeries = [];
var ramThroughputSeries = [];

function updateAlertsSummaryText(text, color) {
    var summaryEl = document.getElementById('alertsSummary');
    if (!summaryEl) return;
    summaryEl.innerText = text;
    if (color) summaryEl.style.color = color;
}

function prepareRamVerificationRun() {
    ramHistoryLabels.length = 0;
    ramMismatchSeries.length = 0;
    ramThroughputSeries.length = 0;
    if (alertsChart) {
        alertsChart.update('none');
    }
    updateAlertsSummaryText('Awaiting first verification sample.', '#666');
}

function clearRamHistory() {
    ramHistoryLabels.length = 0;
    ramMismatchSeries.length = 0;
    ramThroughputSeries.length = 0;
    if (alertsChart) {
        alertsChart.update('none');
    }
    updateAlertsSummaryText('History cleared. Awaiting verification data.', '#666');
}

function ensureAlertsChart() {
    if (alertsChart) return;
    if (typeof Chart === 'undefined') return;
    var ctx = document.getElementById('alertsChart');
    if (!ctx) return;
    alertsChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: ramHistoryLabels,
            datasets: [
                {
                    label: 'Mismatch Count',
                    data: ramMismatchSeries,
                    borderColor: '#dc3545',
                    backgroundColor: 'rgba(220,53,69,0.12)',
                    yAxisID: 'y',
                    tension: 0.3,
                    fill: true,
                    spanGaps: true,
                    pointRadius: 3
                },
                {
                    label: 'Throughput (GB/s)',
                    data: ramThroughputSeries,
                    borderColor: '#17a2b8',
                    backgroundColor: 'rgba(23,162,184,0.12)',
                    yAxisID: 'y1',
                    tension: 0.3,
                    fill: true,
                    spanGaps: true,
                    pointRadius: 3
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: true,
            animation: false,
            scales: {
                y: {
                    beginAtZero: true,
                    title: { display: true, text: 'Mismatches' }
                },
                y1: {
                    beginAtZero: true,
                    position: 'right',
                    title: { display: true, text: 'Throughput (GB/s)' },
                    grid: { drawOnChartArea: false }
                }
            },
            plugins: {
                legend: { display: true, position: 'top' }
            }
        }
    });
}

function initializeRamMirrorChart() {
    if (ramMirrorChart) return;
    if (typeof Chart === 'undefined') return;
    var canvas = document.getElementById('alertsRamChart');
    if (!canvas) return;
    if (!hwCharts || !hwCharts.ram || !hwCharts.ram.data || !hwCharts.ram.data.datasets || hwCharts.ram.data.datasets.length === 0) return;

    var labelsRef = hwCharts.ram.data.labels;
    var datasetRef = hwCharts.ram.data.datasets[0];

    ramMirrorChart = new Chart(canvas, {
        type: 'line',
        data: {
            labels: labelsRef,
            datasets: [
                {
                    label: datasetRef.label,
                    data: datasetRef.data,
                    borderColor: datasetRef.borderColor,
                    backgroundColor: datasetRef.backgroundColor,
                    fill: datasetRef.fill,
                    tension: datasetRef.tension || 0.3,
                    spanGaps: datasetRef.spanGaps || false,
                    pointRadius: datasetRef.pointRadius || 0
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: true,
            animation: false,
            scales: {
                x: { display: false },
                y: { beginAtZero: true, max: 100 }
            },
            plugins: {
                legend: { display: false },
                tooltip: {
                    callbacks: {
                        label: function(ctx) {
                            var percent = (typeof ctx.parsed.y === 'number') ? ctx.parsed.y : NaN;
                            return formatRamTooltip(percent);
                        }
                    }
                }
            }
        }
    });
}

function recordRamHistory(entry) {
    if (!entry) return;
    ensureAlertsChart();
    var label = (entry.pattern || '?') + ' #' + entry.iteration;
    ramHistoryLabels.push(label);
    var mismatchValue = (typeof entry.mismatches === 'number' && isFinite(entry.mismatches)) ? entry.mismatches : 0;
    ramMismatchSeries.push(mismatchValue);
    ramThroughputSeries.push(typeof entry.throughputGBps === 'number' && isFinite(entry.throughputGBps) ? entry.throughputGBps : 0);

    if (ramHistoryLabels.length > alertsHistoryLimit) {
        ramHistoryLabels.shift();
        ramMismatchSeries.shift();
        ramThroughputSeries.shift();
    }

    if (alertsChart) {
        alertsChart.update('none');
    }

    updateAlertsSummary(entry);
}

function CreateAlertsChart() {
    ensureAlertsChart();
    initializeRamMirrorChart();
}

function updateAlertsSummary(entry) {
    if (!entry) return;
    var mismatchText = entry.mismatches > 0 ? entry.mismatches + ' mismatch' + (entry.mismatches === 1 ? '' : 'es') : 'No mismatches';
    var throughputText = formatThroughput(entry.throughputGBps);
    var durationText = formatDuration(entry.durationMs);
    var summary = (entry.pattern || '?') + ' iteration ' + entry.iteration + ': ' + mismatchText + ' • ' + throughputText + ' • ' + durationText;
    if (typeof entry.bytesTotal === 'number' && entry.bytesTotal > 0) {
        summary += ' • ' + formatMegabytes(entry.bytesTotal / (1024 * 1024)) + ' checked';
    }
    var color = entry.mismatches > 0 ? '#dc3545' : '#28a745';
    updateAlertsSummaryText(summary, color);
}

function resetRamVerificationDisplay() {
    var statusEl = document.getElementById('ramVerificationStatus');
    var mismatchEl = document.getElementById('ramMismatchStatus');
    var throughputEl = document.getElementById('ramThroughputStatus');
    if (!statusEl || !mismatchEl) return;
    statusEl.innerText = 'RAM verification idle.';
    statusEl.style.color = '#666';
    mismatchEl.innerText = 'Awaiting verification data.';
    mismatchEl.style.color = '#666';
    if (throughputEl) {
        throughputEl.innerText = 'Throughput: --';
        throughputEl.style.color = '#666';
    }
    updateAlertsSummaryText('RAM verification idle.', '#666');
}

function setRamVerificationPending() {
    var statusEl = document.getElementById('ramVerificationStatus');
    var mismatchEl = document.getElementById('ramMismatchStatus');
    var throughputEl = document.getElementById('ramThroughputStatus');
    if (!statusEl || !mismatchEl) return;
    statusEl.innerText = 'RAM verification running...';
    statusEl.style.color = '#0056b3';
    mismatchEl.innerText = 'Awaiting verification data.';
    mismatchEl.style.color = '#0056b3';
    if (throughputEl) {
        throughputEl.innerText = 'Throughput: pending...';
        throughputEl.style.color = '#0056b3';
    }
    updateAlertsSummaryText('Awaiting verification data.', '#0056b3');
}

function updateRamStressProgress(result) {
    if (!result) return;
    var statusEl = document.getElementById('ramVerificationStatus');
    var mismatchEl = document.getElementById('ramMismatchStatus');
    var throughputEl = document.getElementById('ramThroughputStatus');
    if (!statusEl || !mismatchEl) return;

    var pattern = result.pattern ? String(result.pattern).toUpperCase() : '?';
    var iteration = typeof result.iteration === 'number' ? result.iteration : 0;
    var mismatches = typeof result.mismatches === 'number' ? result.mismatches : 0;
    var ramMb = typeof result.ramAllocatedMB === 'number' ? result.ramAllocatedMB : 0;
    var durationMs = typeof result.durationMs === 'number' ? result.durationMs : null;
    var throughputGbps = typeof result.throughputGBps === 'number' ? result.throughputGBps : null;
    var bytesTotal = typeof result.bytesTotal === 'number' ? result.bytesTotal : null;
    var bytesProcessed = typeof result.bytesProcessed === 'number' ? result.bytesProcessed : null;

    var progressText = 'Pattern ' + pattern + ' iteration ' + iteration + ' verified.';
    if (ramMb > 0) {
        progressText += ' Active allocation: ' + formatMegabytes(ramMb) + '.';
        var ramStatusEl = document.getElementById('ramStatus');
        if (ramStatusEl) {
            ramStatusEl.innerText = 'RAM stress active: ' + formatMegabytes(ramMb) + ' allocated.';
        }
    }

    if (mismatches > 0) {
        statusEl.innerText = progressText;
        statusEl.style.color = '#dc3545';
        var expected = formatByte(result.expected);
        var observed = formatByte(result.observed);
        var offsetDetail = result.firstOffset !== null && result.firstOffset !== undefined
            ? ' First mismatch at byte ' + formatNumber(result.firstOffset) + '.'
            : '';
        mismatchEl.innerText = mismatches + ' mismatches detected (expected ' + expected + ', observed ' + observed + ').' + offsetDetail;
        mismatchEl.style.color = '#dc3545';
    } else {
        statusEl.innerText = progressText;
        statusEl.style.color = '#28a745';
        mismatchEl.innerText = 'No mismatches detected.';
        mismatchEl.style.color = '#28a745';
    }

    if (throughputEl) {
        var throughputText = 'Throughput: ' + formatThroughput(throughputGbps);
        if (durationMs !== null) {
            throughputText += ' (' + formatDuration(durationMs) + ')';
        }
        throughputEl.innerText = throughputText;
        throughputEl.style.color = mismatches > 0 ? '#dc3545' : '#28a745';
    }

    recordRamHistory({
        pattern: pattern,
        iteration: iteration,
        mismatches: mismatches,
        throughputGBps: throughputGbps,
        durationMs: durationMs,
        bytesTotal: bytesTotal,
        bytesProcessed: bytesProcessed
    });
}

function handleRamStressError(message) {
    var statusEl = document.getElementById('ramVerificationStatus');
    var mismatchEl = document.getElementById('ramMismatchStatus');
    var throughputEl = document.getElementById('ramThroughputStatus');
    if (!statusEl || !mismatchEl) return;
    statusEl.innerText = 'RAM verification error.';
    statusEl.style.color = '#dc3545';
    mismatchEl.innerText = message || 'Unknown error.';
    mismatchEl.style.color = '#dc3545';
    if (throughputEl) {
        throughputEl.innerText = 'Throughput: --';
        throughputEl.style.color = '#dc3545';
    }
    updateAlertsSummaryText(message || 'RAM verification error.', '#dc3545');
}

function handleHostBroadcastMessage(message) {
    if (!message || !message.broadcast) return;
    if (message.broadcast === 'ramStressProgress') {
        updateRamStressProgress(message.result || {});
    } else if (message.broadcast === 'ramStressError') {
        var payload = message.result || {};
        handleRamStressError(payload.message || 'RAM stress error.');
    }
}

function GetTotalRuns() { var inputVal = parseInt(document.getElementById("runCountInput").value, 10); return Math.max(1, isNaN(inputVal) ? 1 : inputVal); }

function UpdateThreadAndRunCountStatus() {
    var selector = document.getElementById("threadSelector");
    var numThreads = selector ? parseInt(selector.value, 10) : 8;
    var ramSelector = document.getElementById("ramSelector");
    var ramMb = ramSelector ? parseInt(ramSelector.value, 10) : 0;
    document.getElementById("processCount").innerText = describeCpuTarget(numThreads);
    document.getElementById("ramStatus").innerText = describeRamTarget(ramMb);
    var totalRuns = GetTotalRuns();
    if (!is_benchmark_running) {
        var singleDurText = BENCHMARK_CHUNK_DURATION.toFixed(1).replace(/\.0$/, "");
        var multiDurText = (MULTI_BENCH_DURATION * totalRuns).toFixed(1).replace(/\.0$/, "");
        UpdateStatus("benchStatus", "Ready: single-core " + totalRuns + " runs (~" + singleDurText + "s each). Multi-core runs for ~" + multiDurText + "s total.", "#0056b3");
    }
}

function InitializeCoresSelector() {
    hostInvoke('getCpuInfo', {}).then(function (proc) {
        if (!proc || !proc.success) return;
        var maxCores = proc.threads || proc.logicalProcessors || 1;
        var coresInput = document.getElementById("coresInput");
        var maxCoresDisplay = document.getElementById("maxCoresDisplay");
        if (coresInput) {
            coresInput.max = maxCores;
            coresInput.value = Math.min(coresInput.value || 1, maxCores);
        }
        if (maxCoresDisplay) {
            maxCoresDisplay.innerText = "(max: " + maxCores + ")";
        }
    }).catch(function () {
        // Use a reasonable default if we can't get CPU info
        var coresInput = document.getElementById("coresInput");
        if (coresInput) coresInput.max = 16;
    });
}

function UpdateCoresStatus() {
    var coresInput = document.getElementById("coresInput");
    if (coresInput) {
        var selected = parseInt(coresInput.value, 10);
        var max = parseInt(coresInput.max, 10) || 16;
        if (selected > max) coresInput.value = max;
        if (selected < 1) coresInput.value = 1;
    }
}

// --- WMI replacement: ask host for CPU info ---
function StartStaticInfoFetch() {
    hostInvoke('getCpuInfo', {}).then(function (proc) {
        console.log('CPU Info received:', proc);
        if (!proc || !proc.success) {
            document.getElementById("cpuModel").innerText = "WMI Error: Cannot Fetch Static CPU Info";
            document.getElementById("cpuModel").style.color = "#dc3545";
            return;
        }
        document.getElementById("cpuModel").innerText = proc.name || proc.model || 'Unknown CPU';
        document.getElementById("cpuCores").innerText = proc.cores || 0;
        document.getElementById("cpuThreads").innerText = proc.threads || proc.logicalProcessors || 0;
        var maxClockGhz = proc.maxClockGHz || (proc.maxClockMHz / 1000) || 0;
        document.getElementById("cpuClockMax").innerText = maxClockGhz.toFixed(1) + " GHz";
    }).catch(function () {
        document.getElementById("cpuModel").innerText = "WMI Service Failed to initialize.";
        document.getElementById("cpuModel").style.color = "#dc3545";
    });
}

// --- File & process helpers using host ---
function fileExists(path) { return hostInvoke('fileExists', { path: path }); }
function deleteFile(path) { return hostInvoke('deleteFile', { path: path }); }
function writeFile(path, content) { return hostInvoke('writeFile', { path: path, content: content }); }
function runProcess(cmd, hidden, wait) { return hostInvoke('runProcess', { cmd: cmd, hidden: !!hidden, wait: !!wait }); }

// --- STRESS FUNCTIONS (adapted) ---
function StartStress(mode) {
    console.log("StartStress called with mode:", mode || "heavy");
    mode = mode || "heavy";
    if (is_benchmark_running) { UpdateStatus("stressStatus", "Please stop the Single Core Benchmark before starting the Stress Test.", "#dc3545"); return; }
    var numProcesses = parseInt(document.getElementById("threadSelector").value, 10) || 0;
    var ramMb = parseInt(document.getElementById("ramSelector").value, 10) || 0;

    if (numProcesses <= 0 && ramMb <= 0) {
        UpdateStatus("stressStatus", "Enable CPU or RAM stress before starting.", "#dc3545");
        return;
    }

    var modeLabel = mode === "instability" ? "Instability Check" : "Heavy Load";
    var startMessage = numProcesses > 0 ?
        "Starting " + numProcesses + " " + modeLabel + " processes..." :
        "CPU stress disabled; applying RAM stress selection...";
    UpdateStatus("stressStatus", startMessage, "#0056b3");

    hostInvoke('startStress', { numProcesses: numProcesses, ramMB: ramMb, mode: mode }).then(function (res) {
        console.log("startStress response:", res);
        if (res && res.success) {
            document.getElementById("startBtn").disabled = true;
            document.getElementById("startInstabilityBtn").disabled = true;
            var cpuEnabled = res.cpuEnabled !== false && numProcesses > 0;
            document.getElementById("pauseResumeBtn").disabled = !cpuEnabled;
            document.getElementById("stopBtn").disabled = false;
            document.getElementById("threadSelector").disabled = true;
            document.getElementById("ramSelector").disabled = true;
            document.getElementById("pauseResumeBtn").innerText = "Pause Test";
            var message = res.message || (cpuEnabled ? modeLabel + " stress running." : "RAM stress active.");
            UpdateStatus("stressStatus", message, "#28a745");
            var ramAllocated = typeof res.ramAllocatedMB === 'number' ? res.ramAllocatedMB : (cpuEnabled ? 0 : ramMb);
            document.getElementById("processCount").innerText = describeCpuTarget(cpuEnabled ? numProcesses : 0);
            document.getElementById("ramStatus").innerText = ramAllocated > 0 ? "RAM stress active: " + formatMegabytes(ramAllocated) + " allocated." : "RAM stress disabled.";
            if (ramAllocated > 0) {
                prepareRamVerificationRun();
                setRamVerificationPending();
            } else {
                resetRamVerificationDisplay();
            }
        } else {
            var msg = res && res.message ? res.message : JSON.stringify(res);
            UpdateStatus("stressStatus", "Error starting stress test: " + msg, "#dc3545");
            UpdateThreadAndRunCountStatus();
            resetRamVerificationDisplay();
        }
    }).catch(function (err) {
        UpdateStatus("stressStatus", "Error starting stress test: " + err, "#dc3545");
        UpdateThreadAndRunCountStatus();
        resetRamVerificationDisplay();
    });
}

function TogglePauseResume() {
    var numProcesses = parseInt(document.getElementById("threadSelector").value);
    hostInvoke('togglePauseResume', {}).then(function (result) {
        console.log('togglePauseResume response:', result);
        if (result && result.success && result.isPaused) { 
            document.getElementById("pauseResumeBtn").innerText = "Resume Test"; 
            UpdateStatus("stressStatus", numProcesses + " Processes PAUSED (Low utilization).", "#ffc107"); 
        }
        else if (result && result.success && !result.isPaused) { 
            document.getElementById("pauseResumeBtn").innerText = "Pause Test"; 
            UpdateStatus("stressStatus", numProcesses + " Processes RESUMED to High Stress.", "#28a745"); 
        }
        else { UpdateStatus("stressStatus", "Pause/Resume error: " + (result.message || JSON.stringify(result)), "#dc3545"); }
    }).catch(function (err) { UpdateStatus("stressStatus", "Error toggling pause/resume: " + err, "#dc3545"); });
}

function StopStress() {
    UpdateStatus("stressStatus", "Stopping all processes...", "#0056b3");
    hostInvoke('stopStress', {}).then(function (res) {
        console.log('stopStress response:', res);
        if (res && res.success) {
            document.getElementById("startBtn").disabled = false;
            document.getElementById("startInstabilityBtn").disabled = false;
            document.getElementById("pauseResumeBtn").disabled = true;
            document.getElementById("stopBtn").disabled = true;
            document.getElementById("threadSelector").disabled = false;
            document.getElementById("ramSelector").disabled = false;
            UpdateThreadAndRunCountStatus();
            var message = res.message || "Test Stopped. Ready to begin.";
            UpdateStatus("stressStatus", message, "#0056b3");
            if (typeof res.ramAllocatedMB === 'number') {
                document.getElementById("ramStatus").innerText = res.ramAllocatedMB > 0 ? "RAM stress active: " + formatMegabytes(res.ramAllocatedMB) + " allocated." : "RAM stress disabled.";
            }
            resetRamVerificationDisplay();
        } else {
            var msg = res && res.message ? res.message : JSON.stringify(res);
            UpdateStatus("stressStatus", "Error stopping stress test: " + msg, "#dc3545");
            document.getElementById("ramSelector").disabled = false;
            UpdateThreadAndRunCountStatus();
        }
    }).catch(function (err) {
        UpdateStatus("stressStatus", "Error stopping stress test: " + err, "#dc3545");
        document.getElementById("ramSelector").disabled = false;
        UpdateThreadAndRunCountStatus();
        resetRamVerificationDisplay();
    });
}

// --- BENCHMARK FUNCTIONS (unchanged except WMI/FS usage where needed) ---
// --- HISTOGRAM DATA & LOGIC ---

document.addEventListener('DOMContentLoaded', function() {
    var clearBtn = document.getElementById('clearHistogramBtn');
    var toggleSingleBtn = document.getElementById('toggleSingleBtn');
    var toggleMultiBtn = document.getElementById('toggleMultiBtn');
    var histContainer = document.getElementById('cpuHistogramContainer');
    if (clearBtn) {
        clearBtn.onclick = function() {
            if (currentHistogramMode === 'single') {
                singleCoreScores = [];
            } else {
                multiCoreScores = [];
            }
            updateBenchmarkHistogram();
        };
    }
    if (toggleSingleBtn && toggleMultiBtn) {
        toggleSingleBtn.onclick = function() {
            currentHistogramMode = 'single';
            toggleSingleBtn.classList.add('active');
            toggleMultiBtn.classList.remove('active');
            updateBenchmarkHistogram();
        };
        toggleMultiBtn.onclick = function() {
            currentHistogramMode = 'multi';
            toggleMultiBtn.classList.add('active');
            toggleSingleBtn.classList.remove('active');
            updateBenchmarkHistogram();
        };
    }
    // Auto-switch mode on benchmark start
    window.startSingleCoreBenchmark = function() {
        currentHistogramMode = 'single';
        if (toggleSingleBtn && toggleMultiBtn) {
            toggleSingleBtn.classList.add('active');
            toggleMultiBtn.classList.remove('active');
        }
        updateBenchmarkHistogram();
    };
    window.startMultiCoreBenchmark = function() {
        currentHistogramMode = 'multi';
        if (toggleSingleBtn && toggleMultiBtn) {
            toggleMultiBtn.classList.add('active');
            toggleSingleBtn.classList.remove('active');
        }
        updateBenchmarkHistogram();
    };
    // Hide histogram container on startup if no scores
    var histContainer = document.getElementById('cpuHistogramContainer');
    if (histContainer) {
        histContainer.classList.add('histogram-hidden');
    }
    // Only update histogram after Chart.js is loaded
    window.onChartJsLoaded = function() {
        updateBenchmarkHistogram();
    };
});
let singleCoreScores = [];
let multiCoreScores = [];
let currentHistogramMode = 'single'; // 'single' or 'multi'
let benchmarkHistogramChart = null;

// Export/benchmark tracking
let lastSingleCoreScore = null;
let lastMultiCoreScore = null;
let lastPathTracerScore = null;
let lastCpuName = "";
let systemInfo = { windowsVersion: 10, cores: 4, ramGB: 8 };
let lastBenchmarkTimestamp = null;

function createHistogram(scores, binSize = 5) {
    if (!scores.length) return { labels: [], data: [] };

    const min = Math.min(...scores);
    const max = Math.max(...scores);
    let actualBinSize = binSize;
    if (max > min) {
        actualBinSize = Math.max(5, Math.round((max - min) / 8));
    }

    const start = Math.floor(min / actualBinSize) * actualBinSize;
    const end = Math.ceil(max / actualBinSize) * actualBinSize;

    const labels = [];
    const data = [];

    for (let i = start; i <= end; i += actualBinSize) {
        labels.push(`${i}-${i + actualBinSize - 1}`);
        data.push(0);
    }

    scores.forEach(score => {
        const idx = Math.floor((score - start) / actualBinSize);
        if (idx >= 0 && idx < data.length) data[idx]++;
    });

    return { labels, data };
}

function meanStd(scores) {
    if (!scores.length) return { mean: 0, std: 0 };
    const mean = scores.reduce((a,b)=>a+b,0) / scores.length;
    const variance = scores.reduce((a,b)=>a+(b-mean)**2,0) / scores.length;
    return { mean, std: Math.sqrt(variance) };
}

function updateBenchmarkHistogram() {
    const scores = currentHistogramMode === 'single' ? singleCoreScores : multiCoreScores;
    const hist = createHistogram(scores);
    const { mean, std } = meanStd(scores);
    const meanLine = hist.labels.map(() => mean);
    const upper = hist.labels.map(() => mean + std);
    const lower = hist.labels.map(() => mean - std);
    const ctx = document.getElementById('benchmarkHistogram').getContext('2d');
    // Hide or show histogram container based on scores
    var histContainer = document.getElementById('cpuHistogramContainer');
    if (histContainer) {
        if (!scores.length) {
            histContainer.classList.add('histogram-hidden');
        } else {
            histContainer.classList.remove('histogram-hidden');
            histContainer.classList.remove('faded');
        }
    }
    // Update run count label
    var runLabel = document.getElementById('histogramRunLabel');
    if (runLabel) {
        runLabel.textContent = scores.length ? `Runs: ${scores.length}` : '';
    }
    // Calculate a sensible y-axis max (1.5x the highest bin, at least 2)
    const maxBin = Math.max(2, ...hist.data);
    const yMax = Math.ceil(maxBin * 1.5);
    if (benchmarkHistogramChart) {
        benchmarkHistogramChart.destroy();
        benchmarkHistogramChart = null;
    }
    benchmarkHistogramChart = new Chart(ctx, {
        data: {
            labels: hist.labels,
            datasets: [
                {
                    type: 'bar',
                    data: hist.data,
                    backgroundColor: 'rgba(102,126,234,0.6)',
                    borderRadius: 3
                },
                {
                    type: 'line',
                    data: meanLine,
                    borderColor: '#4caf50',
                    borderDash: [6,4],
                    pointRadius: 0
                },
                {
                    type: 'line',
                    data: upper,
                    borderColor: '#ffa726',
                    borderDash: [4,2],
                    pointRadius: 0
                },
                {
                    type: 'line',
                    data: lower,
                    borderColor: '#ffa726',
                    borderDash: [4,2],
                    pointRadius: 0
                }
            ]
        },
        options: {
            maintainAspectRatio: false,
            plugins: { legend: { display: false } },
            scales: {
                y: { beginAtZero: true, max: yMax, ticks: { precision: 0 } },
                x: { ticks: { maxRotation: 0 } }
            }
        }
    });
}
var BENCHMARK_CHUNK_DURATION = 20.0;
var MULTI_BENCH_DURATION = 6.0;
// Adjusted scaling to better match the original HTA (IE/JScript) performance range.
// WebView2 (Chromium) is much faster, so increase the divisor to scale scores
// down to the historical average. Tweak this value if you want a different mapping.
var SCORE_SCALING_FACTOR = 1601041.6;
var MULTICORE_SCORE_MULTIPLIER = 0.783;  // Scale multicore backend scores to ~235 range
var f_val = 1.000001;
var i_val = 123456789;
var is_benchmark_running = false;
var total_iterations = 0;
var benchmark_start_time = 0;
var run_scores = [];
var current_run = 0;
var multiBenchTimerId = null;
var multiBenchStartTime = 0;
var multiBenchTargetSeconds = MULTI_BENCH_DURATION;
var multiBenchSamplesObserved = 0;

function clearMultiBenchTimer() {
    if (multiBenchTimerId) {
        clearInterval(multiBenchTimerId);
        multiBenchTimerId = null;
    }
}

function updateMultiBenchProgress(elapsedSeconds) {
    var barFill = document.getElementById("progressBarFill");
    var barText = document.getElementById("progressText");
    if (!barFill || !barText) return;
    if (!multiBenchTargetSeconds || multiBenchTargetSeconds <= 0) {
        multiBenchTargetSeconds = MULTI_BENCH_DURATION;
    }
    var clampedElapsed = Math.min(Math.max(elapsedSeconds || 0, 0), multiBenchTargetSeconds);
    var percent = Math.min(100, (clampedElapsed / multiBenchTargetSeconds) * 100);
    var percentText = percent.toFixed(0);
    barFill.style.width = percentText + '%';
    barText.innerText = percentText + '%';

    var details = document.getElementById("benchDetails");
    if (details) {
        var elapsedText = clampedElapsed.toFixed(1).replace(/\.0$/, "");
        var targetText = multiBenchTargetSeconds.toFixed(1).replace(/\.0$/, "");
        var sampleText = multiBenchSamplesObserved > 0 ? " (" + multiBenchSamplesObserved + " samples)" : "";
        details.innerText = "Multi-core test: " + elapsedText + "s of " + targetText + "s" + sampleText + ".";
    }
}

function ResetRunState() { f_val = 1.000001; i_val = 123456789; total_iterations = 0; var date = new Date(); benchmark_start_time = date.getTime() / 1000; }

function StartBenchmark() {
    if (document.getElementById("startBtn").disabled == true) { UpdateStatus("benchStatus", "Please stop the CPU Stress Test before running the benchmark.", "#dc3545"); return; }
    if (is_benchmark_running) return;
    WarmUpCPU(function() {
        var totalRuns = GetTotalRuns();
        run_scores = []; current_run = 1; is_benchmark_running = true;
        document.getElementById("benchBtn").disabled = true; document.getElementById("multiBenchBtn").disabled = true; document.getElementById("runCountInput").disabled = true; document.getElementById("benchResult").innerHTML = "0.00";
        document.getElementById("exportSingleBtn").disabled = true; document.getElementById("exportSingleBtn").style.opacity = "0.5";
        document.getElementById("benchDetails").innerText = "Starting Run 1 of " + totalRuns + " (Duration: " + BENCHMARK_CHUNK_DURATION + "s)";
        UpdateStatus("benchStatus", "Executing single core benchmark...", "#0056b3");
        document.getElementById("progressBarFill").style.width = '0%'; document.getElementById("progressText").innerText = '0%';
        ResetRunState(); setTimeout(RunBenchmarkChunk, 10);
    }, 'single');
}

function StartMultiCoreBenchmark() {
    if (document.getElementById("startBtn").disabled == true) { UpdateStatus("benchStatus", "Please stop the CPU Stress Test before running the benchmark.", "#dc3545"); return; }
    if (is_benchmark_running) return;
    WarmUpCPU(function() {
        is_benchmark_running = true;
        var totalRuns = GetTotalRuns();
        var targetSeconds = MULTI_BENCH_DURATION * totalRuns;
        multiBenchSamplesObserved = 0;
        document.getElementById("benchBtn").disabled = true;
        document.getElementById("multiBenchBtn").disabled = true;
        document.getElementById("runCountInput").disabled = true;
        document.getElementById("benchResult").innerHTML = "0.00";
        document.getElementById("exportMultiBtn").disabled = true; document.getElementById("exportMultiBtn").style.opacity = "0.5";
        document.getElementById("benchDetails").innerText = "Running multi-core benchmark for ~" + targetSeconds.toFixed(1).replace(/\.0$/, "") + " seconds...";
        UpdateStatus("benchStatus", "Executing multi-core benchmark window (" + targetSeconds.toFixed(1).replace(/\.0$/, "") + "s, all threads)...", "#0056b3");
        document.getElementById("progressBarFill").style.width = '0%';
        document.getElementById("progressText").innerText = '0%';

        clearMultiBenchTimer();
        multiBenchTargetSeconds = targetSeconds;
        multiBenchStartTime = Date.now();
        updateMultiBenchProgress(0);
        multiBenchTimerId = setInterval(function () {
            if (!is_benchmark_running) {
                clearMultiBenchTimer();
                return;
            }
            var elapsed = (Date.now() - multiBenchStartTime) / 1000;
            updateMultiBenchProgress(elapsed);
        }, 120);

        function progressListener(e) {
            try {
            var m = e.data;
            if (m && m.broadcast === 'benchmarkProgress') {
                if (m.result && typeof m.result.sampleCount === 'number') {
                    multiBenchSamplesObserved = m.result.sampleCount;
                }
                var elapsed = (m.result && typeof m.result.elapsedSeconds === 'number') ? m.result.elapsedSeconds : null;
                if (typeof elapsed === 'number') {
                    updateMultiBenchProgress(elapsed);
                }
            }
        } catch (err) { }
    }
    window.chrome.webview.addEventListener('message', progressListener);

    hostInvoke('runMultiCoreBenchmark', { durationSeconds: targetSeconds, numRuns: totalRuns })
        .then(function(result) {
            window.chrome.webview.removeEventListener('message', progressListener);
            console.log('Multi-core benchmark result:', result);
            is_benchmark_running = false;
            clearMultiBenchTimer();
            if (result && result.success && result.score > 0) {
                var normalizedScore = result.score / 10;
                var scoreText = normalizedScore.toFixed(2);
                document.getElementById("benchResult").innerHTML = scoreText;
                UpdateStatus("benchStatus", "Multi-Core Benchmark Complete!", "#28a745");
                var durationValue = (typeof result.durationSeconds === 'number' ? result.durationSeconds : targetSeconds);
                var durationText = durationValue.toFixed(1).replace(/\.0$/, "");
                var sampleText = result.samples || multiBenchSamplesObserved || 0;
                multiBenchSamplesObserved = sampleText;
                updateMultiBenchProgress(multiBenchTargetSeconds);
                var runInfo = (result.runsRequested || totalRuns || 1);
                var runScoresText = "Multi-Core: Average of " + sampleText + " samples across " + runInfo + " run(s) over " + durationText + "s.";
                if (result.individualScores && Array.isArray(result.individualScores)) {
                    var multiSum = 0; for (var k = 0; k < result.individualScores.length; k++) { multiSum += result.individualScores[k]; }
                    var multiAvg = multiSum / result.individualScores.length;
                    var formattedScores = "";
                    for (var i = 0; i < result.individualScores.length; i++) {
                        var mScore = (result.individualScores[i] / 10).toFixed(2);
                        var mDiff = Math.abs((result.individualScores[i] - multiAvg) / multiAvg);
                        if (mDiff > 0.1) {
                            formattedScores += "<span style='color: red;'>" + mScore + "</span>";
                        } else {
                            formattedScores += mScore;
                        }
                        if (i < result.individualScores.length - 1) { formattedScores += ", "; }
                    }
                    runScoresText += " Raw: [" + formattedScores + "]";
                }
                document.getElementById("benchDetails").innerHTML = runScoresText;
                
                // Enable multi-core export button, disable single-core (only latest run can export)
                lastMultiCoreScore = normalizedScore;
                lastBenchmarkTimestamp = new Date().toISOString();
                document.getElementById("exportMultiBtn").disabled = false;
                document.getElementById("exportMultiBtn").style.opacity = "1";
                document.getElementById("exportSingleBtn").disabled = true;
                document.getElementById("exportSingleBtn").style.opacity = "0.5";
                
                SaveYourScore(normalizedScore, true);
                // Update histogram for multi-core (accumulate all run scores)
                if (result.individualScores && Array.isArray(result.individualScores)) {
                    for (var i = 0; i < result.individualScores.length; i++) {
                        multiCoreScores.push(result.individualScores[i] / 10);
                    }
                } else {
                    multiCoreScores.push(normalizedScore);
                }
                currentHistogramMode = 'multi';
                updateBenchmarkHistogram();
            } else {
                var msg = result && result.message ? result.message : JSON.stringify(result);
                UpdateStatus("benchStatus", "Multi-Core Benchmark failed: " + msg, "#dc3545");
                document.getElementById("benchDetails").innerText = "Error running benchmark: " + msg;
            }
            document.getElementById("benchBtn").disabled = false;
            document.getElementById("multiBenchBtn").disabled = false;
            document.getElementById("runCountInput").disabled = false;
            UpdateThreadAndRunCountStatus();
        })
        .catch(function(err) {
            window.chrome.webview.removeEventListener('message', progressListener);
            console.error('Multi-core benchmark error:', err);
            is_benchmark_running = false;
            clearMultiBenchTimer();
            UpdateStatus("benchStatus", "Multi-Core Benchmark error: " + err, "#dc3545");
            document.getElementById("benchBtn").disabled = false;
            document.getElementById("multiBenchBtn").disabled = false;
            document.getElementById("runCountInput").disabled = false;
            UpdateThreadAndRunCountStatus();
        });
    }, 'multi');
}

function StartPathTracerBenchmark() {
    if (document.getElementById("startBtn").disabled == true) { UpdateStatus("benchStatus", "Please stop the CPU Stress Test before running the benchmark.", "#dc3545"); return; }
    if (is_benchmark_running) return;
    WarmUpCPU(function() {
        is_benchmark_running = true;
        document.getElementById("benchBtn").disabled = true;
        document.getElementById("multiBenchBtn").disabled = true;
        document.getElementById("ptBenchBtn").disabled = true;
        document.getElementById("runCountInput").disabled = true;
        document.getElementById("coresInput").disabled = true;
        document.getElementById("benchResult").innerHTML = "?.??";
        document.getElementById("benchDetails").innerText = "Running Path Tracer Benchmark (32 samples/pixel)...";
        UpdateStatus("benchStatus", "Running Path Tracer Benchmark...", "#0056b3");
        document.getElementById("progressBarFill").style.width = '50%';
        document.getElementById("progressText").innerText = 'Rendering...';

        var numCores = parseInt(document.getElementById("coresInput").value, 10) || 1;
        var startTime = Date.now();
        var progressTimerId = null;
        
        function updateProgress() {
            // Pulsing progress bar while rendering
            var elapsed = Date.now() - startTime;
            var pulse = 40 + 10 * Math.sin(elapsed / 200);
            document.getElementById("progressBarFill").style.width = pulse.toFixed(0) + '%';
            if (elapsed < 300000) {  // Keep pulsing for up to 5 minutes
                progressTimerId = setTimeout(updateProgress, 100);
            }
        }
        progressTimerId = setTimeout(updateProgress, 100);

        hostInvoke('runPathTracerBenchmark', { numCores: numCores })
            .then(function(result) {
                console.log('Path tracer result:', result);
                is_benchmark_running = false;
                
                // Stop pulsing animation
                if (progressTimerId) clearTimeout(progressTimerId);
                
                // Hide progress bar when complete
                document.getElementById("progressBarFill").style.width = '0%';
                document.getElementById("progressText").innerText = '';
                if (result && result.success && result.score >= 0) {
                    var scoreText = result.score.toFixed(2);
                    document.getElementById("benchResult").innerHTML = scoreText + "s";
                    lastPathTracerScore = result.score;
                    lastBenchmarkTimestamp = new Date().toISOString();
                    UpdateStatus("benchStatus", "Path Tracer Benchmark Complete! (Lower is better)", "#28a745");
                    var spsText = (result.samplesPerSecond || 0).toFixed(0);
                    var samplesText = Math.floor(result.totalSamples || 0).toLocaleString();
                    var durationText = (result.durationSeconds || 6).toFixed(2);
                    var details = "Path Tracer: Rendered in " + durationText + "s (" + samplesText + " samples, " + spsText + " samples/sec)";
                    document.getElementById("benchDetails").innerHTML = details;
                    // Enable export button
                    document.getElementById("exportPTBtn").disabled = false;
                    document.getElementById("exportPTBtn").style.opacity = "1";
                } else {
                    var msg = result && result.message ? result.message : "Unknown error";
                    UpdateStatus("benchStatus", "Path Tracer Benchmark failed: " + msg, "#dc3545");
                    document.getElementById("benchDetails").innerText = "Error: " + msg;
                    document.getElementById("exportPTBtn").disabled = true;
                    document.getElementById("exportPTBtn").style.opacity = "0.5";
                }
                document.getElementById("benchBtn").disabled = false;
                document.getElementById("multiBenchBtn").disabled = false;
                document.getElementById("ptBenchBtn").disabled = false;
                document.getElementById("runCountInput").disabled = false;
                document.getElementById("coresInput").disabled = false;
                UpdateThreadAndRunCountStatus();
            })
            .catch(function(err) {
                console.error('Path tracer error:', err);
                is_benchmark_running = false;
                
                // Stop pulsing animation on error
                if (progressTimerId) clearTimeout(progressTimerId);
                UpdateStatus("benchStatus", "Path Tracer Benchmark error: " + err, "#dc3545");
                document.getElementById("benchDetails").innerText = "Error: " + err;
                document.getElementById("benchBtn").disabled = false;
                document.getElementById("multiBenchBtn").disabled = false;
                document.getElementById("ptBenchBtn").disabled = false;
                document.getElementById("runCountInput").disabled = false;
                document.getElementById("coresInput").disabled = false;
                UpdateThreadAndRunCountStatus();
            });
    }, 'single');
}

function SwitchScoreType() {
    var scoreType = document.getElementById("scoreTypeSelect").value;
    console.log('Score type switched to:', scoreType);
    if (scoreType === 'multicore') {
        // Switch to empty multi-core chart (no data yet)
        CreateBenchmarksChart(true);
    } else {
        // Switch back to single-core chart
        CreateBenchmarksChart(false);
    }
}

function RunBenchmarkChunk() {
    if (!is_benchmark_running) return;
    var totalRuns = GetTotalRuns(); var date = new Date(); var current_time = date.getTime() / 1000; var elapsed_time = current_time - benchmark_start_time;
    var progress_percent = Math.min(100.0, (elapsed_time / BENCHMARK_CHUNK_DURATION) * 100.0);
    if (elapsed_time >= BENCHMARK_CHUNK_DURATION) { document.getElementById("progressBarFill").style.width = '100%'; document.getElementById("progressText").innerText = '100%'; FinishBenchmark(); return; }
    var chunk_end_time = current_time + 0.005;
    while ((new Date().getTime() / 1000) < chunk_end_time) {
        total_iterations++;
        f_val = Math.sqrt(f_val * 0.999999 + 0.000001);
        f_val = Math.sin(f_val * Math.PI);
        f_val = Math.cos(f_val / 2);
        i_val = (i_val * 77) % 2000000000;
        i_val = (i_val * 13 + 5) % 2000000000;
        i_val = (i_val ^ 0xDEADBEEF) % 2000000000;
    }
    var current_score = (total_iterations / SCORE_SCALING_FACTOR).toFixed(2);
    document.getElementById("benchResult").innerHTML = current_score;
    document.getElementById("benchDetails").innerText = "Run " + current_run + " of " + totalRuns + ": Score " + current_score;
    var display_percent = progress_percent.toFixed(0);
    document.getElementById("progressBarFill").style.width = display_percent + '%';
    document.getElementById("progressText").innerText = display_percent + '%';
    setTimeout(RunBenchmarkChunk, 1);
}

function FinishBenchmark() {
    var totalRuns = GetTotalRuns();
    var run_score = total_iterations / SCORE_SCALING_FACTOR; run_scores.push(run_score);
    if (current_run < totalRuns) {
        current_run++; document.getElementById("progressBarFill").style.width = '0%'; document.getElementById("progressText").innerText = '0%'; UpdateStatus("benchStatus", "Run " + (current_run - 1) + " recorded. Starting Run " + current_run + "...", "#0056b3"); document.getElementById("benchDetails").innerText = "Starting Run " + current_run + " of " + totalRuns + " (Duration: " + BENCHMARK_CHUNK_DURATION + "s)"; setTimeout(function() { ResetRunState(); RunBenchmarkChunk(); }, 1500);
    } else {
        is_benchmark_running = false; var sum = 0; for (var i = 0; i < run_scores.length; i++) { sum += run_scores[i]; }
        var average_score = sum / run_scores.length; var display_avg_score = average_score.toFixed(2);
        var raw_scores_list = ""; for (var j = 0; j < run_scores.length; j++) { 
            var score = run_scores[j].toFixed(2);
            var diff = Math.abs((run_scores[j] - average_score) / average_score);
            if (diff > 0.1) {
                raw_scores_list += "<span style='color: red;'>" + score + "</span>";
            } else {
                raw_scores_list += score;
            }
            if (j < run_scores.length - 1) { raw_scores_list += ", "; } 
        }
        document.getElementById("benchResult").innerHTML = display_avg_score; UpdateStatus("benchStatus", "Benchmark Complete! Average Score Displayed.", "#28a745"); document.getElementById("benchDetails").innerHTML = "Single-Core: Average of " + run_scores.length + " Runs (~6 seconds). Raw: [" + raw_scores_list + "]";
        document.getElementById("benchBtn").disabled = false; document.getElementById("multiBenchBtn").disabled = false; document.getElementById("runCountInput").disabled = false; UpdateThreadAndRunCountStatus();
        
        // Enable single-core export button, disable multi-core (only latest run can export)
        lastSingleCoreScore = average_score;
        lastBenchmarkTimestamp = new Date().toISOString();
        document.getElementById("exportSingleBtn").disabled = false;
        document.getElementById("exportSingleBtn").style.opacity = "1";
        document.getElementById("exportMultiBtn").disabled = true;
        document.getElementById("exportMultiBtn").style.opacity = "0.5";
        
        // Save your score and refresh the chart
        SaveYourScore(average_score, false);
        // Update histogram for single-core: push all run scores
        singleCoreScores = [...run_scores];
        run_scores = [];
        currentHistogramMode = 'single';
        updateBenchmarkHistogram();
                    run_scores = [];
    }
}

function Window_OnLoad() {
    // ask host for running directory if not already set by init
    hostInvoke('getAppDir', {}).then(function (dir) { htaDir = dir || htaDir; }).finally(function () { 
        document.getElementById("startBtn").innerText = "Start Stress Test"; 
        document.getElementById("pauseResumeBtn").disabled = true;
        document.getElementById("stopBtn").disabled = true;
        StartStaticInfoFetch(); 
        UpdateThreadAndRunCountStatus();
        InitializeCoresSelector();
        resetRamVerificationDisplay();
        ApplySavedTheme(); 
        InitBenchmarksChart(); 
        CreateHardwareCharts();
        CreateAlertsChart();
        StartHardwarePoll();
    });
}

function Window_OnUnload() { StopStress(); }

// --- Customization functions (non-invasive UI layer) ---
function ApplySavedTheme() {
    try {
        var fg = localStorage.getItem('cpuutil_fg');
        var grad1 = localStorage.getItem('bg_grad1');
        var grad2 = localStorage.getItem('bg_grad2');
        var grad3 = localStorage.getItem('bg_grad3');
        var mainFg = localStorage.getItem('cpuutil_main_fg');
        
        // Apply text colors
        if (fg) document.body.style.color = fg;
        if (mainFg) {
            var main = document.querySelector('.main-container');
            if (main) main.style.color = mainFg;
        }
        
        // Apply gradient colors
        if (grad1) document.body.style.setProperty('--bg-grad1', grad1);
        if (grad2) document.body.style.setProperty('--bg-grad2', grad2);
        if (grad3) document.body.style.setProperty('--bg-grad3', grad3);
        
        // Update control values if present
        var fgInp = document.getElementById('cust_fg'); if (fgInp && fg) fgInp.value = fg;
        var grad1Inp = document.getElementById('cust_grad1'); if (grad1Inp && grad1) grad1Inp.value = grad1;
        var grad2Inp = document.getElementById('cust_grad2'); if (grad2Inp && grad2) grad2Inp.value = grad2;
        var grad3Inp = document.getElementById('cust_grad3'); if (grad3Inp && grad3) grad3Inp.value = grad3;
        var mainFgInp = document.getElementById('cust_main_fg'); if (mainFgInp && mainFg) mainFgInp.value = mainFg;
    } catch (e) { }
}

function SaveTheme() {
    try {
        var fg = document.getElementById('cust_fg').value;
        var grad1 = document.getElementById('cust_grad1').value;
        var grad2 = document.getElementById('cust_grad2').value;
        var grad3 = document.getElementById('cust_grad3').value;
        var mainFg = document.getElementById('cust_main_fg').value;
        
        // Save text colors
        if (fg) { document.body.style.color = fg; localStorage.setItem('cpuutil_fg', fg); }
        if (mainFg) { 
            var main = document.querySelector('.main-container');
            if (main) { main.style.color = mainFg; }
            localStorage.setItem('cpuutil_main_fg', mainFg); 
        }
        
        // Save gradient colors
        if (grad1) { document.body.style.setProperty('--bg-grad1', grad1); localStorage.setItem('bg_grad1', grad1); }
        if (grad2) { document.body.style.setProperty('--bg-grad2', grad2); localStorage.setItem('bg_grad2', grad2); }
        if (grad3) { document.body.style.setProperty('--bg-grad3', grad3); localStorage.setItem('bg_grad3', grad3); }
        
        UpdateStatus('benchStatus','Theme saved.', '#28a745');
    } catch (e) { UpdateStatus('benchStatus','Error saving theme: ' + e.message, '#dc3545'); }
}

function ResetTheme() {
    try {
        // Clear all saved settings
        localStorage.removeItem('cpuutil_fg');
        localStorage.removeItem('cpuutil_main_fg');
        localStorage.removeItem('bg_grad1');
        localStorage.removeItem('bg_grad2');
        localStorage.removeItem('bg_grad3');
        
        // Restore defaults
        document.body.style.color = '#333';
        document.body.style.setProperty('--bg-grad1', '#e0e7ff');
        document.body.style.setProperty('--bg-grad2', '#f0f0f0');
        document.body.style.setProperty('--bg-grad3', '#ffe0e7');
        
        var main = document.querySelector('.main-container');
        if (main) { main.style.color = '#000'; }
        
        // Reset input values
        var fgInp = document.getElementById('cust_fg'); if (fgInp) fgInp.value = '#333333';
        var grad1Inp = document.getElementById('cust_grad1'); if (grad1Inp) grad1Inp.value = '#e0e7ff';
        var grad2Inp = document.getElementById('cust_grad2'); if (grad2Inp) grad2Inp.value = '#f0f0f0';
        var grad3Inp = document.getElementById('cust_grad3'); if (grad3Inp) grad3Inp.value = '#ffe0e7';
        var mainFgInp = document.getElementById('cust_main_fg'); if (mainFgInp) mainFgInp.value = '#000000';
        
        UpdateStatus('benchStatus','Theme reset to defaults.', '#0056b3');
    } catch (e) { UpdateStatus('benchStatus','Error resetting theme: ' + e.message, '#dc3545'); }
}

function ToggleSidebar() {
    var sb = document.getElementById('customSidebar');
    if (!sb) return;
    sb.classList.toggle('open');
    var t = document.getElementById('settingsToggle');
    if (sb.classList.contains('open')) t.innerText = '✖'; else t.innerText = '⚙';
    // close all other sidebars if open
    var bs = document.getElementById('benchmarksSidebar');
    if (bs && bs.classList.contains('open')) {
        bs.classList.remove('open');
        var bt = document.getElementById('benchmarksToggle');
        if (bt) bt.innerText = '📊';
    }
    var as = document.getElementById('alertsSidebar');
    if (as && as.classList.contains('open')) {
        as.classList.remove('open');
        var at = document.getElementById('alertsToggle');
        if (at) at.innerText = '⚠';
    }
    var ws = document.getElementById('wheaSidebar');
    if (ws && ws.classList.contains('open')) {
        ws.classList.remove('open');
        var wt = document.getElementById('wheaToggle');
        if (wt) wt.innerText = '⚡';
    }
    var abt = document.getElementById('aboutSidebar');
    if (abt && abt.classList.contains('open')) {
        abt.classList.remove('open');
        var abtt = document.getElementById('aboutToggle');
        if (abtt) abtt.innerText = 'ℹ';
    }
}

function ToggleBenchmarks() {
    var bs = document.getElementById('benchmarksSidebar');
    if (!bs) return;
    bs.classList.toggle('open');
    var t = document.getElementById('benchmarksToggle');
    if (bs.classList.contains('open')) t.innerText = '✖'; else t.innerText = '📊';
    // close all other sidebars if open
    var sb = document.getElementById('customSidebar');
    if (sb && sb.classList.contains('open')) {
        sb.classList.remove('open');
        var st = document.getElementById('settingsToggle');
        if (st) st.innerText = '⚙';
    }
    var as = document.getElementById('alertsSidebar');
    if (as && as.classList.contains('open')) {
        as.classList.remove('open');
        var at = document.getElementById('alertsToggle');
        if (at) at.innerText = '⚠';
    }
    var ws = document.getElementById('wheaSidebar');
    if (ws && ws.classList.contains('open')) {
        ws.classList.remove('open');
        var wt = document.getElementById('wheaToggle');
        if (wt) wt.innerText = '⚡';
    }
    var abt = document.getElementById('aboutSidebar');
    if (abt && abt.classList.contains('open')) {
        abt.classList.remove('open');
        var abtt = document.getElementById('aboutToggle');
        if (abtt) abtt.innerText = 'ℹ';
    }
}

function ToggleAlerts() {
    var as = document.getElementById('alertsSidebar');
    if (!as) return;
    as.classList.toggle('open');
    var t = document.getElementById('alertsToggle');
    if (as.classList.contains('open')) {
        if (t) t.innerText = '✖';
        ensureAlertsChart();
        initializeRamMirrorChart();
        if (alertsChart) {
            alertsChart.update('none');
        }
        if (ramMirrorChart) {
            ramMirrorChart.update('none');
        }
    } else if (t) {
        t.innerText = '⚠';
    }

    // close all other sidebars if open
    var sb = document.getElementById('customSidebar');
    if (sb && sb.classList.contains('open')) {
        sb.classList.remove('open');
        var st = document.getElementById('settingsToggle');
        if (st) st.innerText = '⚙';
    }
    var bs = document.getElementById('benchmarksSidebar');
    if (bs && bs.classList.contains('open')) {
        bs.classList.remove('open');
        var bt = document.getElementById('benchmarksToggle');
        if (bt) bt.innerText = '📊';
    }
    var ws = document.getElementById('wheaSidebar');
    if (ws && ws.classList.contains('open')) {
        ws.classList.remove('open');
        var wt = document.getElementById('wheaToggle');
        if (wt) wt.innerText = '⚡';
    }
    var abt = document.getElementById('aboutSidebar');
    if (abt && abt.classList.contains('open')) {
        abt.classList.remove('open');
        var abtt = document.getElementById('aboutToggle');
        if (abtt) abtt.innerText = 'ℹ';
    }
}

// --- Benchmarks Chart Data & Initialization ---
var cpuBenchmarkData = [
    { cpu: 'i7-4770K', score: 37 },
    { cpu: 'i5-7200U', score: 31.5 },
    { cpu: 'N200', score: 33 },
    { cpu: 'FX-4300', score: 19 },
    { cpu: 'Core i5-210H', score: 60 },
    { cpu: 'i7-6700', score: 39.5 },
    { cpu: 'Ryzen 7 7700X', score: 65 },
    { cpu: 'Ryzen 5 7600X', score: 65 },
    { cpu: 'Ryzen 5 3600', score: 41 },
    { cpu: 'i7-5960X 4.3GHz', score: 43.5 },
    { cpu: 'Ryzen 9 9950X', score: 72 }
];

// Multi-core benchmark data (empty for now - will be populated as users test)
var cpuMultiCoreBenchmarkData = [
    { cpu: 'i5-7200U', score: 105 },
    { cpu: 'i7-4770K', score: 215 },
    { cpu: 'Core i5-210H', score: 515 },
    { cpu: 'i7-6700', score: 230 },
    { cpu: 'Ryzen 5 7600X', score: 685 },
    { cpu: 'Ryzen 7 9700X', score: 700 },
    { cpu: 'i7-5960X 4.3GHz', score: 530 },
    { cpu: 'Ryzen 9 9950X', score: 1700 }
];

var benchmarkChart = null;

function SaveYourScore(score, isMultiCore) {
    var key = isMultiCore ? 'cpuutil_your_multicore_score' : 'cpuutil_your_score';
    localStorage.setItem(key, score.toFixed(2));
    RefreshBenchmarksChart();
}

function GetYourScore(isMultiCore) {
    var key = isMultiCore ? 'cpuutil_your_multicore_score' : 'cpuutil_your_score';
    var stored = localStorage.getItem(key);
    if (!stored) return null;
    var value = parseFloat(stored);
    if (isNaN(value)) return null;
    return value;
}

// SHA256 implementation (simplified for JSON hashing)
async function GenerateSHA256Hash(data) {
    const encoder = new TextEncoder();
    const dataBuffer = encoder.encode(data);
    const hashBuffer = await crypto.subtle.digest('SHA-256', dataBuffer);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    return hashHex;
}

// Fetch system info from C# backend
async function GetSystemInfo() {
    try {
        console.log('GetSystemInfo: Calling hostInvoke...');
        var result = await hostInvoke('getSystemInfo', {});
        console.log('GetSystemInfo: Result received:', result);
        
        if (result && result.success) {
            systemInfo = {
                windowsVersion: result.windowsVersion || 10,
                cores: result.cores || 4,
                ramGB: result.ramGB || 8
            };
            console.log('GetSystemInfo: systemInfo updated:', systemInfo);
        }
        return systemInfo;
    } catch (err) {
        console.error('GetSystemInfo: Error:', err);
        return systemInfo;
    }
}

// Export benchmark score with anti-tamper verification
async function ExportBenchmarkScore(scoreType) {
    console.log('ExportBenchmarkScore called with scoreType:', scoreType);
    try {
        // Determine which score to export
        var score;
        if (scoreType === 'single') {
            score = lastSingleCoreScore;
        } else if (scoreType === 'multi') {
            score = lastMultiCoreScore;
        } else if (scoreType === 'pathtracer') {
            score = lastPathTracerScore;
        }
        var runCount = GetTotalRuns();
        
        console.log('Score:', score, 'RunCount:', runCount);
        
        if (!score) {
            console.log('No score found, updating status');
            UpdateStatus("benchStatus", "No benchmark score to export yet.", "#dc3545");
            return;
        }
        
        console.log('Getting CPU info...');
        // Get CPU info first
        var cpuInfo = await hostInvoke('getCpuInfo', {});
        console.log('CPU Info received:', cpuInfo);
        var cpuName = cpuInfo.name || cpuInfo.model || "Unknown CPU";
        console.log('CPU Name:', cpuName);
        
        console.log('Getting system info...');
        // Ensure system info is current
        await GetSystemInfo();
        console.log('System Info:', systemInfo);
        
        // Create export object
        var exportData = {
            version: "1.9.0",
            exportDate: lastBenchmarkTimestamp || new Date().toISOString(),
            scoreType: scoreType,
            score: parseFloat(score.toFixed(2)),
            runCount: runCount,
            hardware: {
                cpu: cpuName,
                cores: systemInfo.cores,
                ramGB: systemInfo.ramGB,
                windowsVersion: systemInfo.windowsVersion
            }
        };
        
        console.log('Export data created:', exportData);
        
        // Generate verification hash from concatenated values
        var hashInput = JSON.stringify({
            score: exportData.score,
            cpu: exportData.hardware.cpu,
            cores: exportData.hardware.cores,
            ram: exportData.hardware.ramGB,
            windows: exportData.hardware.windowsVersion,
            date: exportData.exportDate,
            version: exportData.version
        });
        
        console.log('Generating SHA256 hash...');
        var hash = await GenerateSHA256Hash(hashInput);
        console.log('Hash generated:', hash);
        exportData.verification = {
            hash: hash,
            algorithm: "SHA256"
        };
        
        // Trigger file download with Save As dialog
        console.log('Creating blob and preparing download...');
        var jsonStr = JSON.stringify(exportData, null, 2);
        var blob = new Blob([jsonStr], { type: 'application/json' });
        var url = URL.createObjectURL(blob);
        var link = document.createElement('a');
        link.href = url;
        
        // Generate filename
        var typeStr = scoreType === 'single' ? 'SC' : 'MC';
        var scoreVal = score.toFixed(2).replace('.', '-');
        var dateStr = new Date().toISOString().split('T')[0];
        link.download = 'XenoCPU_' + typeStr + '_' + scoreVal + '_' + dateStr + '.json';
        
        console.log('Download filename:', link.download);
        
        // Trigger download
        console.log('Triggering download...');
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        
        console.log('Download triggered successfully');
        UpdateStatus("benchStatus", "Benchmark score exported successfully!", "#28a745");
    } catch (err) {
        console.error('Export error:', err);
        console.error('Error stack:', err.stack);
        UpdateStatus("benchStatus", "Error exporting score: " + (err.message || err), "#dc3545");
    }
}

function RefreshBenchmarksChart() {
    if (benchmarkChart) {
        benchmarkChart.destroy();
        benchmarkChart = null;
    }
    var scoreType = document.getElementById("scoreTypeSelect") ? document.getElementById("scoreTypeSelect").value : 'singlecore';
    CreateBenchmarksChart(scoreType === 'multicore');
}

function InitBenchmarksChart() {
    // Load Chart.js from local file to avoid CDN/tracking issues
    var script = document.createElement('script');
    script.src = 'chart.4.4.1.min.js';
    script.onload = function() {
        CreateBenchmarksChart();
        CreateHardwareCharts();
        StartHardwarePoll();
        CreateAlertsChart();
        if (window.onChartJsLoaded) window.onChartJsLoaded();
    };
    document.head.appendChild(script);
}

function CreateBenchmarksChart(isMultiCore) {
    if (typeof Chart === 'undefined') return;
    var ctx = document.getElementById('benchmarksChart');
    if (!ctx) return;

    if (benchmarkChart) {
        benchmarkChart.destroy();
    }

    var chartData;
    var chartTitle;
    var maxScore;

    if (isMultiCore) {
        chartTitle = 'Multi-Core Score';
        maxScore = 2000;
        chartData = cpuMultiCoreBenchmarkData.slice();
        var yourMultiScore = GetYourScore(true);
        if (yourMultiScore !== null) {
            chartData.push({ cpu: 'Your CPU', score: yourMultiScore });
        }
    } else {
        chartTitle = 'Single-Core Score';
        maxScore = 80;
        chartData = cpuBenchmarkData.slice();
        var yourScore = GetYourScore(false);
        if (yourScore !== null) {
            chartData.push({ cpu: 'Your CPU', score: yourScore });
        }
    }

    chartData.sort(function (a, b) { return a.score - b.score; });

    // Set canvas width dynamically based on number of scores
    var numScores = chartData.length;
    var minWidth = 320;
    var widthPerScore = 50;
    var dynamicWidth = Math.max(minWidth, numScores * widthPerScore);
    ctx.width = dynamicWidth;
    // Set different heights for single-core vs multi-core
    var chartHeight = isMultiCore ? 600 : 1100;
    ctx.height = chartHeight;

    var labels = chartData.map(function (item) { return item.cpu; });
    var scores = chartData.map(function (item) { return item.score; });

    var colors = scores.map(function (s, idx) {
        return labels[idx] === 'Your CPU' ? '#28a745' : '#007bff';
    });
    var borderColors = scores.map(function (s, idx) {
        return labels[idx] === 'Your CPU' ? '#1f7e34' : '#0056b3';
    });

    benchmarkChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: chartTitle,
                data: scores,
                backgroundColor: colors,
                borderColor: borderColors,
                borderWidth: 1,
                barPercentage: 0.68,
                categoryPercentage: 0.92
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            indexAxis: 'x',
            scales: {
                x: {
                    ticks: {
                        maxRotation: 45,
                        minRotation: 45,
                        font: {
                            size: 10
                        }
                    }
                },
                y: { beginAtZero: true, max: maxScore }
            },
            plugins: {
                legend: { display: true, position: 'top' }
            }
        }
    });
}

// --- Hardware monitoring charts ---
var hwCharts = { temp: null, volt: null, cpu: null, ram: null };
var hwSeriesMax = 25;

function CreateHardwareCharts() {
    if (typeof Chart === 'undefined') return;
    // create empty datasets
    try {
        var cctx = document.getElementById('cpuChart');
        var rctx = document.getElementById('ramChart');
        if (!cctx || !rctx) return;

        hwCharts.cpu = new Chart(cctx, {
            type: 'line', data: { labels: [], datasets: [{ label: 'CPU Utilization (%)', data: [], borderColor: '#4caf50', backgroundColor: 'rgba(76,175,80,0.06)', fill: true }] }, options: { animation: false, responsive: true, scales: { x: { display: false }, y: { beginAtZero: true, max: 100 } }, plugins: { tooltip: { callbacks: { label: function(ctx) { return 'CPU: ' + ctx.parsed.y.toFixed(1) + '%'; } } } } }
        });
        
        hwCharts.ram = new Chart(rctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    {
                        label: 'RAM Usage (%)',
                        data: [],
                        borderColor: '#ff9800',
                        backgroundColor: 'rgba(255,152,0,0.06)',
                        fill: true
                    }
                ]
            },
            options: {
                animation: false,
                responsive: true,
                scales: {
                    x: { display: false },
                    y: { beginAtZero: true, max: 100 }
                },
                plugins: {
                    tooltip: {
                        callbacks: {
                            label: function(ctx) {
                                var percent = (typeof ctx.parsed.y === 'number') ? ctx.parsed.y : NaN;
                                return formatRamTooltip(percent);
                            }
                        }
                    }
                }
            }
        });
        initializeRamMirrorChart();
    } catch (e) { console.error('Chart creation error:', e); }
}

function StartHardwarePoll() {
    // poll every second
    setInterval(async function () {
        try {
            var m = await hostInvoke('getHardwareMetrics', {});
            var ts = new Date();
            var label = ts.getHours().toString().padStart(2,'0')+ ':' + ts.getMinutes().toString().padStart(2,'0')+ ':' + ts.getSeconds().toString().padStart(2,'0');
            if (m) {
                if (typeof m.RamTotalGB === 'number' && !isNaN(m.RamTotalGB)) {
                    window.lastRamMetrics = {
                        totalGB: m.RamTotalGB,
                        availableGB: typeof m.AvailableRamGB === 'number' ? m.AvailableRamGB : null,
                        usedGB: typeof m.RamUsedGB === 'number' ? m.RamUsedGB : null
                    };
                }
                if (hwCharts.freq) {
                    var freqVal = (m.CpuFreqMHz !== null && m.CpuFreqMHz !== undefined && m.CpuFreqMHz > 0) ? Number(m.CpuFreqMHz) : null;
                    pushPoint(hwCharts.freq, label, freqVal);
                }
                if (hwCharts.cpu) {
                    var cpuVal = (m.CpuLoad !== null && m.CpuLoad !== undefined) ? Number(m.CpuLoad) : null;
                    pushPoint(hwCharts.cpu, label, cpuVal);
                }
                if (hwCharts.ram) {
                    var ramVal = (m.RamUsagePercent !== null && m.RamUsagePercent !== undefined) ? Number(m.RamUsagePercent) : null;
                    pushPoint(hwCharts.ram, label, ramVal);
                }
            }
        } catch (e) { console.error('Hardware poll error:', e); }
    }, 1000);
}

function pushPoint(chart, label, value) {
    try {
        if (!chart) return;
        var ds = chart.data.datasets[0];
        chart.data.labels.push(label);
        ds.data.push(value === null ? NaN : value);
        if (chart.data.labels.length > hwSeriesMax) { chart.data.labels.shift(); ds.data.shift(); }
        chart.update('active');
        if (ramMirrorChart && chart === hwCharts.ram) {
            ramMirrorChart.update('active');
        }
    } catch (e) { }
}

function DumpSensors() {
    hostInvoke('getHardwareSensors', {}).then(function(sensors) {
        console.log('=== All Available Sensors ===');
        console.table(sensors);
        alert('Sensor data dumped to console (press F12 to view). Check the console for all sensor names and values.');
    }).catch(function(err) {
        console.error('Failed to get sensors:', err);
        alert('Failed to get sensors. Check console for errors.');
    });
}
</script>
</head>

<body onload="Window_OnLoad()" onunload="Window_OnUnload()">
    <div class="main-container">

        <!-- Stress Controller Panel -->
        <div class="panel stress-panel">
            <h1>Multi-Core Stress Controller</h1>
            <p>Launches independent, processes for maximum, sustained CPU load.</p>
            
            <div class="stress-control-row" style="margin-bottom: 20px;">
                <label for="threadSelector" style="font-weight: 600;">Select Stress Threads:</label>
                <select id="threadSelector" onchange="UpdateThreadAndRunCountStatus()">
                    <option value="0">CPU Stress Disabled</option>
                    <option value="1">1 Thread</option>
                    <option value="2">2 Threads</option>
                    <option value="4">4 Threads</option>
                    <option value="6">6 Threads</option>
                    <option value="8" selected>8 Threads (Default)</option>
                    <option value="12">12 Threads</option>
                    <option value="16">16 Threads</option>
                    <option value="20">20 Threads</option>
                    <option value="24">24 Threads</option>
                    <option value="32">32 Threads</option>
                    <option value="48">48 Threads</option>
                    <option value="64">64 Threads</option>
                </select>
            </div>

            <div class="stress-control-row" style="margin-bottom: 20px;">
                <label for="ramSelector" style="font-weight: 600;">Select RAM Stress:</label>
                <select id="ramSelector" onchange="UpdateThreadAndRunCountStatus()">
                    <option value="0" selected>RAM Stress Disabled</option>
                    <option value="256">256 MB</option>
                    <option value="512">512 MB</option>
                    <option value="4096">4 GB</option>
                    <option value="8192">8 GB</option>
                    <option value="16384">16 GB</option>
                    <option value="32768">32 GB</option>
                    <option value="65536">64 GB</option>
                    <option value="98304">96 GB</option>
                    <option value="131072">128 GB</option>
                </select>
            </div>
            
            <div class="status-text" id="stressStatus">Ready.</div>
            
            <p class="status-text" id="processCount" style="margin-top: -15px; font-size: 0.9em; font-weight: normal; color: #666;"></p>
            <p class="status-text" id="ramStatus" style="margin-top: -20px; font-size: 0.9em; font-weight: normal; color: #666;"></p>
            <p class="status-text" id="ramVerificationStatus" style="margin-top: -20px; font-size: 0.85em; font-weight: normal; color: #666;">RAM verification idle.</p>
            <p class="status-text" id="ramMismatchStatus" style="margin-top: -22px; font-size: 0.85em; font-weight: normal; color: #666;">Awaiting verification data.</p>
            <p class="status-text" id="ramThroughputStatus" style="margin-top: -22px; font-size: 0.85em; font-weight: normal; color: #666;">Throughput: --</p>
            

            <div class="button-group">
                <button id="startBtn" onclick="StartStress('heavy')">Heavy Load Stress</button>
                <button id="startInstabilityBtn" onclick="StartStress('instability')">Instability Check</button>
                <button id="pauseResumeBtn" onclick="TogglePauseResume()" disabled>Pause Test</button>
                <button id="stopBtn" onclick="StopStress()" disabled>Stop All</button>
            </div>
            
            <p style="font-size:0.8em; margin-top:20px; color:#a0a0a0;">
                *Processes run hidden in the background for sustained load.
            </p>
        </div>

        <!-- Stable Single Core Benchmark & Static Info Panel (Combined) -->
        <div class="panel benchmark-panel">
            <h1>Stable Single Core Benchmark</h1>
            <p>Averaging multiple runs mitigates operating system interference and yields a stable result.</p>
            
            <!-- User Input for Run Count -->
            <div class="run-count-control">
                <label for="runCountInput" style="font-weight: 600;">Number of Runs:</label>
                <input type="number" id="runCountInput" value="3" min="1" oninput="UpdateThreadAndRunCountStatus()">
            </div>
            
            <!-- Core Count for Path Tracer -->
            <div class="cores-control">
                <label for="coresInput" style="font-weight: 600;">Path Tracer Cores:</label>
                <input type="number" id="coresInput" value="1" min="1" oninput="UpdateCoresStatus()">
                <span id="maxCoresDisplay" style="margin-left: 15px; font-size: 0.9em; color: #666;"></span>
            </div>
            
            <button id="benchBtn" onclick="StartBenchmark()" style="margin-bottom: 10px;">Run Single Core Benchmark</button>
            <button id="multiBenchBtn" onclick="StartMultiCoreBenchmark()" style="margin-bottom: 10px;">Run Multi Core Benchmark</button>
            <button id="ptBenchBtn" onclick="StartPathTracerBenchmark()" style="margin-bottom: 10px;">Run Path Tracer Benchmark</button>
            
            <div class="progress-bar-wrapper">
                <div class="progress-bar" id="progressBarFill"></div>
                <div id="progressText">0%</div>
            </div>

            <div class="status-text" id="benchStatus" style="margin-top: 20px;"></div>
            
            <span class="score-display" id="benchResult">0.00</span>
            
            <div style="margin-top: 10px; display: flex; gap: 10px;">
                <button id="exportSingleBtn" class="export-btn" onclick="ExportBenchmarkScore('single')" disabled style="background-color: #28a745; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; opacity: 0.5;">Export Single-Core Score</button>
                <button id="exportMultiBtn" class="export-btn" onclick="ExportBenchmarkScore('multi')" disabled style="background-color: #28a745; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; opacity: 0.5;">Export Multi-Core Score</button>
                <button id="exportPTBtn" class="export-btn" onclick="ExportBenchmarkScore('pathtracer')" disabled style="background-color: #17a2b8; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer; opacity: 0.5;">Export Path Tracer Score</button>
            </div>
            
            <p id="benchDetails">Set the number of runs above and press 'Run Stable Benchmark' to start.</p>

                        <div id="cpuHistogramContainer">
                            <div class="histogram-toggle-row">
                                <span class="histogram-run-label" id="histogramRunLabel"></span>
                                <!-- Single/Multi buttons removed -->
                                <button id="clearHistogramBtn">Clear</button>
                            </div>
                            <div class="histogramHeader">
                                <span>Score Distribution</span>
                            </div>
                            <canvas id="benchmarkHistogram" width="320" height="160"></canvas>
                        </div>
            
            <!-- Static CPU Info Section -->
            <div class="static-info-container">
                <h2>CPU Hardware Details</h2>
                <div style="font-weight: 600; font-size: 1.1em; color: #0056b3; margin-bottom: 10px;" id="cpuModel">Fetching CPU Model...</div>
                <div class="static-specs">
                    <div>
                        Max Clock<br>
                        <strong><span id="cpuClockMax">-- GHz</span></strong>
                    </div>
                    <div>
                        Cores<br>
                        <strong><span id="cpuCores">--</span></strong>
                    </div>
                    <div>
                        Threads<br>
                        <strong><span id="cpuThreads">--</span></strong>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Sidebar Toggle Buttons (Settings + Benchmarks + About) -->
    <div class="sidebar-toggle-row">
        <button id="wheaToggle" onclick="ToggleWhea()">⚡</button>
        <button id="alertsToggle" onclick="ToggleAlerts()">⚠</button>
        <button id="settingsToggle" onclick="ToggleSidebar()">⚙</button>
        <button id="benchmarksToggle" onclick="ToggleBenchmarks()">📊</button>
        <button id="aboutToggle" onclick="ToggleAbout()">ℹ</button>
    </div>

    <!-- WHEA Errors Sidebar -->
    <div id="wheaSidebar" class="whea-sidebar" aria-hidden="true">
        <h3>WHEA Errors (CPU Instability)</h3>
        <p style="margin-top:4px; font-size:0.9em; color:#666">Monitor Windows Hardware Error Architecture events. Errors detected during stress testing indicate CPU instability.</p>
        
        <h4>Error Summary</h4>
        <div id="wheaSummary" class="whea-summary">Monitoring for WHEA events. No errors detected yet.</div>
        
        <h4>Recent Errors</h4>
        <div id="wheaErrorList" class="whea-error-list">
            <div style="font-size: 0.9em; color: #999; text-align: center; padding: 15px 0;">No errors logged</div>
        </div>
        
        <button type="button" class="whea-clear-btn" onclick="ClearWheaErrors()">Clear History</button>
    </div>

    <!-- Alerts Sidebar -->
    <div id="alertsSidebar" class="alerts-sidebar" aria-hidden="true">
        <h3>Verification Alerts</h3>
        <p style="margin-top:4px; font-size:0.9em; color:#444">Track RAM pattern mismatches and throughput per iteration.</p>
        <canvas id="alertsChart" width="300" height="220"></canvas>
        <h4 style="margin-top:16px; color:#0056b3;">RAM Usage (Live)</h4>
        <canvas id="alertsRamChart" width="300" height="120"></canvas>
        <div id="alertsSummary" class="alerts-summary">No verification data yet.</div>
        <button type="button" class="alerts-clear-btn" onclick="clearRamHistory()">Clear History</button>
    </div>

    <!-- Customization Sidebar -->
    <div id="customSidebar" class="custom-sidebar" aria-hidden="true">
        <h3>Customize Appearance</h3>
        <p style="margin-top:4px; font-size:0.9em; color:#444">Change background and text colors. Settings persist locally.</p>




        <label for="cust_fg">Page Text Color</label>
        <input type="color" id="cust_fg" value="#333333">


        <label for="cust_grad1">Background Gradient Top</label>
        <input type="color" id="cust_grad1" value="#e0e7ff">
        <label for="cust_grad2">Background Gradient Middle</label>
        <input type="color" id="cust_grad2" value="#f0f0f0">
        <label for="cust_grad3">Background Gradient Bottom</label>
        <input type="color" id="cust_grad3" value="#ffe0e7">

        <label for="cust_main_fg">Main Panel Text Color</label>
        <input type="color" id="cust_main_fg" value="#000000">

        <div style="margin-top:12px; display:flex; align-items:center;">
            <button class="save-btn" onclick="SaveTheme()">Save</button>
            <button class="reset-btn" onclick="ResetTheme()">Reset</button>
        </div>

        <div style="margin-top:14px; font-size:0.85em; color:#666">Tip: Use sensible contrasts for readability.</div>
    </div>
<script>
(function() {
    function setGradient(g1, g2, g3) {
        document.body.style.setProperty('--bg-grad1', g1);
        document.body.style.setProperty('--bg-grad2', g2);
        document.body.style.setProperty('--bg-grad3', g3);
    }
    function loadGradient() {
        const g1 = localStorage.getItem('bg_grad1') || '#e0e7ff';
        const g2 = localStorage.getItem('bg_grad2') || '#f0f0f0';
        const g3 = localStorage.getItem('bg_grad3') || '#ffe0e7';
        setGradient(g1, g2, g3);
        var el1 = document.getElementById('cust_grad1');
        var el2 = document.getElementById('cust_grad2');
        var el3 = document.getElementById('cust_grad3');
        if (el1 && el2 && el3) {
            el1.value = g1;
            el2.value = g2;
            el3.value = g3;
        }
    }
    function saveGradient() {
        const g1 = document.getElementById('cust_grad1').value;
        const g2 = document.getElementById('cust_grad2').value;
        const g3 = document.getElementById('cust_grad3').value;
        localStorage.setItem('bg_grad1', g1);
        localStorage.setItem('bg_grad2', g2);
        localStorage.setItem('bg_grad3', g3);
        setGradient(g1, g2, g3);
    }
    function resetGradient() {
        setGradient('#e0e7ff', '#f0f0f0', '#ffe0e7');
        document.getElementById('cust_grad1').value = '#e0e7ff';
        document.getElementById('cust_grad2').value = '#f0f0f0';
        document.getElementById('cust_grad3').value = '#ffe0e7';
        localStorage.removeItem('bg_grad1');
        localStorage.removeItem('bg_grad2');
        localStorage.removeItem('bg_grad3');
    }
    window.addEventListener('DOMContentLoaded', function() {
        loadGradient();
        var el1 = document.getElementById('cust_grad1');
        var el2 = document.getElementById('cust_grad2');
        var el3 = document.getElementById('cust_grad3');
        if (el1 && el2 && el3) {
            el1.addEventListener('input', saveGradient);
            el2.addEventListener('input', saveGradient);
            el3.addEventListener('input', saveGradient);
        }
        var resetBtn = document.querySelector('.reset-btn');
        if (resetBtn) resetBtn.addEventListener('click', resetGradient);
    });
})();
</script>


    <!-- About Sidebar -->
    <div id="aboutSidebar" class="about-sidebar" aria-hidden="true">
        <h3>About Xeno CPU Utility</h3>
        
        <div class="info-section">
            <h4 style="margin-top: 0;">What is this?</h4>
            <p>Xeno CPU Utility is a comprehensive CPU benchmarking and stress testing tool designed for Windows systems. It provides accurate performance measurements, real-time monitoring, and advanced stability testing for processors from entry-level to high-end systems.</p>
        </div>

        <div class="info-section">
            <h4 style="margin-top: 0;">Features</h4>
            <p><strong>• Single & Multi-Core Benchmarks:</strong> Measure performance across all CPU cores with statistical averaging.</p>
            <p><strong>• Heavy Load Stress:</strong> Sustained CPU saturation testing with smooth floating-point workloads.</p>
            <p><strong>• Instability Check:</strong> Advanced 4-phase stress testing designed to expose overclocking marginal failures similar to Prime95 and y-cruncher.</p>
            <p><strong>• Hardware Monitoring:</strong> Live CPU utilization, RAM usage, temperature, and frequency tracking.</p>
            <p><strong>• RAM Verification:</strong> Pattern-based memory integrity checking with throughput measurement.</p>
        </div>

        <div class="info-section">
            <h4 style="margin-top: 0;">How to Use</h4>
            <p><strong>Benchmarking:</strong> For a good, stable score, run 5-10 iterations. Longer per-run durations provide better thermal stabilization and accuracy. Press "Run Single Core" or "Run Multi Core" to start.</p>
            <p><strong>Stress Testing:</strong> Select thread count, choose Heavy Load or Instability Check, then press Start.</p>
            <p><strong>Monitoring:</strong> Use the 📊 tab to view CPU utilization, RAM usage, temperatures, and benchmark comparisons in real-time.</p>
        </div>

        <div class="info-section">
            <h4 style="margin-top: 0;">Version</h4>
            <p>Xeno CPU Utility v1.9.0</p>
        </div>

        <div class="info-section">
            <h4 style="margin-top: 0;">Credits</h4>
            <p><strong>Development:</strong> Created with C# .NET 8 and WebView2</p>
            <p><strong>Benchmarking Algorithms:</strong> Optimized FP and integer workloads with thread synchronization</p>
            <p><strong>Architecture:</strong> Independent stress process threads with barrier synchronization and priority scheduling</p>
        </div>

        <div class="info-section">
            <h4 style="margin-top: 0;">Notes</h4>
            <p>Close background applications before benchmarking for accurate results. This utility respects your system's thermal and power limits.</p>
        </div>
    </div>

    <!-- Benchmarks Sidebar -->
    <div id="benchmarksSidebar" class="benchmarks-sidebar" aria-hidden="true">
        <h3>CPU Benchmark Comparison</h3>
        <p style="margin-top:4px; font-size:0.9em; color:#444">Your system's score vs. other CPUs (average runs).</p>
        <div style="margin-bottom:10px;">
            <label for="scoreTypeSelect" style="font-size:0.9em; color:#333; margin-right:8px;">Score Type:</label>
            <select id="scoreTypeSelect" onchange="SwitchScoreType()" style="padding:4px 8px; font-size:0.9em; border:1px solid #ccc; border-radius:4px;">
                <option value="singlecore">Single Core</option>
                <option value="multicore">Multi Core</option>
            </select>
        </div>
        <div style="overflow: hidden; border: 1px solid #e0e0e0; border-radius: 4px; padding: 10px;">
            <canvas id="benchmarksChart" width="300" height="400"></canvas>
        </div>
        <p style="margin-top:12px; font-size:0.85em; color:#666">Chart shows single-core benchmark scores from various systems.</p>
        <hr style="margin-top:14px; border:none; border-top:1px solid #eee;">
        <h3 style="margin-top:12px;">Hardware Monitoring (Live)</h3>
        <p style="margin-top:4px; font-size:0.9em; color:#444">Temperature, voltage, and core frequency (updates every second when available).</p>
        <div style="font-size:0.85em; color:#666; margin-bottom:6px;">Data from Windows Performance Counters and hardware sensors.</div>
        <div style="font-size:0.78em; color:#888; margin-bottom:8px;">
            <strong>Note:</strong> Temperature/voltage sensors may not be available on all systems (especially laptops).
        </div>
        <!-- CPU Frequency graph removed -->
        <h4 style="margin-top:16px; color:#0056b3;">CPU Utilization</h4>
        <canvas id="cpuChart" width="300" height="120"></canvas>
        <h4 style="margin-top:16px; color:#0056b3;">RAM Usage</h4>
        <canvas id="ramChart" width="300" height="120"></canvas>
    </div>

</body>
<script>
function ToggleWhea() {
    var ws = document.getElementById('wheaSidebar');
    if (!ws) return;
    ws.classList.toggle('open');
    var t = document.getElementById('wheaToggle');
    if (ws.classList.contains('open')) t.innerText = '✖'; else t.innerText = '⚡';
    // close all other sidebars if open
    var sb = document.getElementById('customSidebar');
    if (sb && sb.classList.contains('open')) {
        sb.classList.remove('open');
        var st = document.getElementById('settingsToggle');
        if (st) st.innerText = '⚙';
    }
    var bs = document.getElementById('benchmarksSidebar');
    if (bs && bs.classList.contains('open')) {
        bs.classList.remove('open');
        var bt = document.getElementById('benchmarksToggle');
        if (bt) bt.innerText = '📊';
    }
    var as = document.getElementById('alertsSidebar');
    if (as && as.classList.contains('open')) {
        as.classList.remove('open');
        var at = document.getElementById('alertsToggle');
        if (at) at.innerText = '⚠';
    }
    var abt = document.getElementById('aboutSidebar');
    if (abt && abt.classList.contains('open')) {
        abt.classList.remove('open');
        var abtt = document.getElementById('aboutToggle');
        if (abtt) abtt.innerText = 'ℹ';
    }
}

function ClearWheaErrors() {
    document.getElementById('wheaSummary').innerHTML = 'Error history cleared. Monitoring for new WHEA events.';
    document.getElementById('wheaErrorList').innerHTML = '<div style="font-size: 0.9em; color: #999; text-align: center; padding: 15px 0;">No errors logged</div>';
}

function ToggleAbout() {
    var abt = document.getElementById('aboutSidebar');
    if (!abt) return;
    abt.classList.toggle('open');
    var t = document.getElementById('aboutToggle');
    if (abt.classList.contains('open')) t.innerText = '✖'; else t.innerText = 'ℹ';
    // close all other sidebars if open
    var sb = document.getElementById('customSidebar');
    if (sb && sb.classList.contains('open')) {
        sb.classList.remove('open');
        var st = document.getElementById('settingsToggle');
        if (st) st.innerText = '⚙';
    }
    var bs = document.getElementById('benchmarksSidebar');
    if (bs && bs.classList.contains('open')) {
        bs.classList.remove('open');
        var bt = document.getElementById('benchmarksToggle');
        if (bt) bt.innerText = '📊';
    }
    var as = document.getElementById('alertsSidebar');
    if (as && as.classList.contains('open')) {
        as.classList.remove('open');
        var at = document.getElementById('alertsToggle');
        if (at) at.innerText = '⚠';
    }
    var ws = document.getElementById('wheaSidebar');
    if (ws && ws.classList.contains('open')) {
        ws.classList.remove('open');
        var wt = document.getElementById('wheaToggle');
        if (wt) wt.innerText = '⚡';
    }
}

window.Window_OnLoad = Window_OnLoad;
window.Window_OnUnload = Window_OnUnload;
window.ToggleSidebar = ToggleSidebar;
window.ToggleBenchmarks = ToggleBenchmarks;
window.StartMultiCoreBenchmark = StartMultiCoreBenchmark;
window.ToggleAlerts = ToggleAlerts;
window.StartStress = StartStress;
window.ToggleAbout = ToggleAbout;
window.ToggleWhea = ToggleWhea;
window.ClearWheaErrors = ClearWheaErrors;
</script>
</html>
